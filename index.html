<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Longest Day</title>
    <style>
        /* --- CSS --- */
        body {
            margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #333; font-family: 'Arial', sans-serif; overflow: hidden;
            /* Improve pixel art rendering */
            image-rendering: -moz-crisp-edges; /* Firefox */
            image-rendering: -webkit-crisp-edges; /* Chrome, Safari */
            image-rendering: pixelated; /* Standard */
            image-rendering: crisp-edges;
        }
        #game-container {
            position: relative;
            width: 800px; /* TILE_SIZE * WORLD_WIDTH_TILES */
            height: 608px; /* TILE_SIZE * WORLD_HEIGHT_TILES */
            background-color: #3399FF; /* Default to water color */
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        #game-canvas {
            position: absolute; top: 0; left: 0; background-color: transparent; cursor: default; /* Default cursor */
             /* Improve pixel art rendering on canvas too */
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #stats-panel { position: absolute; top: 10px; left: 10px; background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px; border-radius: 5px; pointer-events: auto; font-size: 14px; }
        #stats-panel div { margin-bottom: 5px; }

        /* --- Updated Inventory Panel Styles --- */
        #inventory-panel {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
            pointer-events: auto;
            z-index: 5;
        }
        #inventory-slots-container {
            display: flex;
            gap: 10px; /* Gap between slots */
        }
        .inventory-slot {
            width: 50px; /* Keep slot size */
            height: 50px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid #555;
            display: flex; /* Use flex to help center content if needed */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            position: relative; /* Needed for absolute positioning of count */
            overflow: hidden;
            box-sizing: border-box;
            cursor: pointer;

            /* Default: No background sprite */
            background-image: none;
            background-repeat: no-repeat;
            background-position: center center; /* Center sprite within the slot */
             /* Scale the sprite view (e.g., 16x16 sprite shown as 32x32) */
            background-size: 32px 32px;
             /* Keep pixel art crisp */
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .inventory-slot.selected {
            border-color: #ffcc00;
            box-shadow: 0 0 5px #ffcc00;
        }
        /* Hide item name text when sprite is shown */
        .inventory-item-name {
             display: none; /* Hide by default */
             font-weight: bold;
             font-size: 9px;
             color: #ddd;
             text-shadow: 1px 1px 1px #000;
             position: absolute;
             top: 2px;
             left: 2px;
             right: 2px; /* Allow wrapping */
             text-align: center;
             word-break: break-word;
        }
        /* Show name only if the slot has the 'no-sprite' class */
        .inventory-slot.no-sprite .inventory-item-name {
             display: block;
        }

        .inventory-count {
            position: absolute; /* Position relative to slot */
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            font-weight: bold;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 1; /* Ensure count is above icon */
            pointer-events: none; /* Don't interfere with slot click */
        }


        /* --- Inventory Navigation Button Styles --- */
        .inv-nav-button {
            background-color: rgba(255, 255, 255, 0.3);
            border: 1px solid #888;
            color: white;
            font-size: 20px;
            font-weight: bold;
            width: 25px;
            height: 50px;
            cursor: pointer;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1;
            padding: 0;
        }
        .inv-nav-button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.5);
        }
        .inv-nav-button:disabled {
            background-color: rgba(100, 100, 100, 0.3);
            color: #aaa;
            cursor: not-allowed;
            border-color: #555;
        }
        /* --- End Inventory Styles --- */

        #tooltip-area { position: absolute; bottom: 75px; left: 50%; transform: translateX(-50%); background-color: rgba(50, 50, 80, 0.85); color: #e0e0e0; padding: 6px 12px; border-radius: 4px; font-size: 13px; text-align: center; max-width: 60%; display: none; z-index: 10; pointer-events: none; }
        #crafting-panel { position: absolute; top: 50%; right: 10px; transform: translateY(-50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 15px; border-radius: 5px; display: none; flex-direction: column; gap: 8px; pointer-events: auto; max-height: 80%; overflow-y: auto; z-index: 15; }
        #crafting-panel h3 { margin-top: 0; margin-bottom: 10px; text-align: center; }
        .craft-button { padding: 8px 12px; background-color: #5a5a5a; border: 1px solid #777; color: white; cursor: pointer; text-align: left; border-radius: 3px; font-size: 13px; }
        .craft-button .craft-req { display: block; font-size: 11px; color: #cccccc; margin-top: 3px; }
        .craft-button:hover:not(:disabled) { background-color: #777; }
        .craft-button:disabled { background-color: #444; color: #888; cursor: not-allowed; border-color: #555; }
        #close-crafting { margin-top: 10px; padding: 8px; background-color: #d9534f; border: none; color: white; cursor: pointer; border-radius: 3px; }
        #close-crafting:hover { background-color: #c9302c; }
        #message-box { position: absolute; top: 70px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.75); color: white; padding: 8px 15px; border-radius: 5px; max-width: 70%; text-align: center; display: none; font-size: 14px; z-index: 10; pointer-events: none; }
        #interaction-prompt { position: absolute; bottom: 90px; left: 50%; transform: translateX(-50%); background-color: rgba(20, 60, 20, 0.8); color: #e8ffe8; padding: 5px 10px; border-radius: 4px; font-size: 13px; text-align: center; max-width: 50%; display: none; z-index: 10; pointer-events: none; }
        #day-night-indicator { position: absolute; top: 10px; right: 10px; width: 50px; height: 50px; border-radius: 50%; border: 2px solid white; transition: background 1s linear, box-shadow 1s linear; }
        #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: none; flex-direction: column; justify-content: center; align-items: center; color: white; pointer-events: auto; z-index: 20; }
        #game-over h2 { font-size: 36px; margin-bottom: 15px; }
        #days-survived { font-size: 18px; margin-bottom: 25px; max-width: 80%; text-align: center; }
        #restart-button { padding: 12px 25px; margin-top: 20px; background-color: #8cc751; border: none; color: white; cursor: pointer; font-size: 18px; border-radius: 5px; transition: background-color 0.3s; }
        #restart-button:hover { background-color: #7bb540; }
        #title-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; pointer-events: auto; z-index: 20; }
        #title-screen h1 { font-size: 40px; color: #8cc751; margin-bottom: 15px; }
        #start-button { padding: 12px 25px; margin-top: 20px; background-color: #8cc751; border: none; color: white; cursor: pointer; font-size: 18px; border-radius: 5px; transition: background-color 0.3s; }
        #start-button:hover { background-color: #7bb540; }
        #instructions { margin-top: 25px; max-width: 80%; text-align: center; font-size: 14px; line-height: 1.6; }
        #instructions p { margin: 5px 0; }
        #instructions b { color: #ffcc00; } /* Highlight keys */

         /* Leaderboard Styles */
        #leaderboard-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70%;
            max-width: 500px;
            max-height: 80%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            z-index: 25; /* Ensure it's above other UI */
            display: none; /* Initially hidden */
            flex-direction: column;
            pointer-events: auto; /* Allow interaction */
        }
        #leaderboard-panel h2 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
            color: #8cc751;
        }
        #leaderboard-content {
             overflow-y: auto; /* Allow scrolling if content exceeds height */
             margin-bottom: 15px;
             display: flex;
             flex-direction: column;
             gap: 15px; /* Space between sections */
        }
        .leaderboard-section h3 {
            margin-bottom: 8px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
            font-size: 16px;
        }
        #leaderboard-panel ol {
            list-style-type: none;
            padding-left: 0;
            margin-left: 0;
        }
        #leaderboard-panel li {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 6px 10px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center; /* Vertically align items */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
         #leaderboard-panel li .rank { font-weight: bold; margin-right: 10px; min-width: 25px; } /* Ensure rank has space */
         #leaderboard-panel li .name { flex-grow: 1; margin-right: 10px; word-break: break-all; } /* Allow long names to break */
         #leaderboard-panel li .score { font-weight: bold; margin-right: 10px; color: #ffcc00; white-space: nowrap; } /* Prevent score text wrapping */
         #leaderboard-panel li .date { font-size: 11px; color: #aaa; white-space: nowrap; } /* Prevent date wrapping */
         #leaderboard-panel li:nth-child(odd) {
             background-color: rgba(255, 255, 255, 0.08);
         }
        #close-leaderboard {
            margin-top: 10px;
            padding: 10px 15px;
            background-color: #d9534f;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 3px;
            align-self: center; /* Center the close button */
        }
        #close-leaderboard:hover {
            background-color: #c9302c;
        }
        /* Style for the button on the title screen */
        #show-leaderboard-button {
             padding: 10px 20px;
             margin-top: 15px;
             background-color: #5a5a5a;
             border: none;
             color: white;
             cursor: pointer;
             font-size: 16px;
             border-radius: 5px;
             transition: background-color 0.3s;
        }
         #show-leaderboard-button:hover {
             background-color: #777;
         }

    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="800" height="608"></canvas> <!-- Adjusted height -->
        <div id="ui-layer">
            <!-- UI Elements -->
            <div id="stats-panel">
                <div>Health: <span id="health-value">100</span>/<span class="max-stat">100</span></div>
                <div>Hunger: <span id="hunger-value">100</span>/<span class="max-stat">100</span></div>
                <div>Thirst: <span id="thirst-value">100</span>/<span class="max-stat">100</span></div>
                <div>Day: <span id="day-value">1</span></div>
            </div>
            <!-- Updated Inventory Panel Structure -->
            <div id="inventory-panel">
                <button id="inv-nav-left" class="inv-nav-button"><</button>
                <div id="inventory-slots-container">
                    <!-- Slots generated by JS -->
                </div>
                <button id="inv-nav-right" class="inv-nav-button">></button>
            </div>
            <div id="tooltip-area">Tooltip text here</div>
            <div id="crafting-panel">
                <h3>Crafting</h3>
                <!-- Crafting buttons generated by JS -->
                <button id="close-crafting">Close</button>
            </div>
            <div id="day-night-indicator"></div>
            <div id="message-box"></div>
            <div id="interaction-prompt"></div>
            <div id="game-over">
                <h2 id="game-over-title">Game Over</h2>
                <div id="days-survived">You survived for 0 days</div>
                <button id="restart-button">Play Again</button>
            </div>
            <div id="title-screen">
                <h1>The Longest Day</h1>
                <div id="instructions">
                     <p>You are stranded on a deserted island. Survive as long as possible!</p>
                     <p><b>WASD</b> or <b>Arrow Keys</b> to move</p>
                     <p><b>E</b> to interact/collect resources/add fuel/use purifier/pick up shelter</p> 
                     <p><b>C</b> to open/close crafting menu</p>
                     <p><b>1-5</b> to select VISIBLE inventory slot</p>
                     <p><b>Space</b> to use selected item (eat food, place objects)</p>
                     <p><b><</b> / <b>></b> buttons (or click) to navigate inventory</p>
                     <p><b>Click</b> a placed Shelter to enter/exit it for protection.</p>
                     <p><i>Survive past Day 3 and keep a large signal fire lit for a chance of rescue!</i></p>
                </div>
                <button id="start-button">Start Game</button>
                <button id="show-leaderboard-button">Leaderboard</button> <!-- Leaderboard Button -->
            </div>

             <!-- Leaderboard Panel -->
            <div id="leaderboard-panel">
                 <h2>Leaderboard</h2>
                 <div id="leaderboard-content">
                     <div class="leaderboard-section">
                         <h3>Longest Days Survived</h3>
                         <ol id="lb-days"></ol>
                     </div>
                     <div class="leaderboard-section">
                         <h3>Most Items Collected</h3>
                         <ol id="lb-items"></ol>
                     </div>
                      <div class="leaderboard-section">
                         <h3>Most Fish Caught</h3>
                         <ol id="lb-fish"></ol>
                     </div>
                 </div>
                 <button id="close-leaderboard">Close</button>
            </div>
        </div> <!-- Close UI Layer -->
    </div> <!-- Close game-container -->

    <script>
        // --- Constants ---
        const TILE_SIZE = 32;
        const WORLD_WIDTH_TILES = 25; // 800 / 32
        const WORLD_HEIGHT_TILES = 19; // 608 / 32
        const WORLD_WIDTH = WORLD_WIDTH_TILES * TILE_SIZE;
        const WORLD_HEIGHT = WORLD_HEIGHT_TILES * TILE_SIZE;
        const VISIBLE_INVENTORY_SLOTS = 5; // How many slots are visible at once
        const MAX_INVENTORY_SIZE = 20; // Total capacity of the inventory
        const MAX_STAT = 100;
        const RESCUE_START_DAY = 4;
        const BASE_RESCUE_CHANCE = 0.15;
        const TREE_REGROW_DAYS = 365; // Long regrow time
        const BAMBOO_REGROW_DAYS = 3;
        const BAMBOO_HEALTH = 2;
        const BAMBOO_WOOD_YIELD = 1;
        const TERRAIN_GRASS = 'grass';
        const TERRAIN_SAND = 'sand';
        const TERRAIN_WATER = 'water'; // Added water terrain type
        const FISHING_ZONE_Y_START = WORLD_HEIGHT_TILES * 0.7; // Relative Y, might need adjustment based on island shape
        const MAX_PURIFIER_DIST_TO_EDGE = 60; // Distance check for purifier placement
        const LEADERBOARD_MAX_ENTRIES = 10; // Leaderboard size
        const SPRITESHEET_SRC = 'tiny_texture_pack.png'; // <-- Path to your spritesheet

        // --- DOM Elements ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const messageBox = document.getElementById('message-box');
        const interactionPrompt = document.getElementById('interaction-prompt');
        const tooltipArea = document.getElementById('tooltip-area');
        const gameOverScreen = document.getElementById('game-over');
        const gameOverTitle = document.getElementById('game-over-title');
        const daysSurvivedText = document.getElementById('days-survived');
        const statsPanel = { health: document.getElementById('health-value'), hunger: document.getElementById('hunger-value'), thirst: document.getElementById('thirst-value'), day: document.getElementById('day-value'), };
        document.querySelectorAll('.max-stat').forEach(el => el.textContent = MAX_STAT);
        // Inventory DOM Elements
        const inventorySlotsContainer = document.getElementById('inventory-slots-container');
        const invNavLeftButton = document.getElementById('inv-nav-left');
        const invNavRightButton = document.getElementById('inv-nav-right');
        // Leaderboard DOM Elements
        const leaderboardPanel = document.getElementById('leaderboard-panel');
        const lbDaysList = document.getElementById('lb-days');
        const lbItemsList = document.getElementById('lb-items');
        const lbFishList = document.getElementById('lb-fish');


        // --- Game State ---
        let gameStarted = false; let gameOver = false; let rescued = false;
        let player = {}; // Initialized in resetGameState
        let stats = { // Expanded stats object
            health: MAX_STAT, hunger: MAX_STAT, thirst: MAX_STAT, day: 1,
            totalItemsCollected: 0,
            fishCaught: 0
        };
        let inventory = []; // Will hold up to MAX_INVENTORY_SIZE items
        let selectedSlot = 0; // Absolute index in the full inventory array
        let inventoryStartIndex = 0; // Index of the first visible slot
        let time = {}; let world = [];
        let trees = []; let rocks = []; let bambooStands = [];
        let campfires = []; let shelters = []; let waterFilters = []; let signalFires = [];
        let keys = {}; let messageTimeout = null; let interactionTimeout = null; let tooltipTimeout = null;
        let hintFlags = {};
        let grassPatches = [];
        let spritesheet = null; // To hold the loaded image object
        let spritesheetLoaded = false; // Flag to check if loaded

        // --- Resources & Crafting Definitions (with Sprite Coords) ---
        // sx, sy: top-left corner of sprite in the sheet (in pixels)
        // sw, sh: width and height of the sprite in the sheet (usually 16x16 for this pack)
        const resources = {
            wood: { name: 'Wood', description: 'Basic building material.', sprite: { sx: 0, sy: 16, sw: 16, sh: 16 } },
            stone: { name: 'Stone', description: 'Sturdy material for tools.', sprite: { sx: 16, sy: 16, sw: 16, sh: 16 } },
            fish: { name: 'Fish', heals: 3, restoresHunger: 30, description: 'Eat (Space) for nourishment.', sprite: { sx: 32, sy: 16, sw: 16, sh: 16 } },
            // Add other resources here if they have sprites
        };
        const craftableItems = {
            axe: { name: 'Axe', requires: { wood: 5, stone: 2 }, description: 'Chops trees faster.', sprite: { sx: 0, sy: 32, sw: 16, sh: 16 } },
            fishingRod: { name: 'Fishing Rod', requires: { wood: 3 }, description: 'Enables fishing.', sprite: { sx: 16, sy: 32, sw: 16, sh: 16 } },
            // Placeable items usually don't need an inventory *icon* sprite, but you could add one if desired
            campfire: { name: 'Campfire', requires: { wood: 10, stone: 3 }, placeable: true, width: 48, height: 48, description: 'Place (Space) for light/warmth.', sprite: { sx: 16, sy: 0, sw: 16, sh: 16 } }, // Example: using fire sprite
            shelter: { name: 'Shelter', requires: { wood: 20 }, placeable: true, pickupable: true, width: 64, height: 48, description: 'Place (Space). Click to enter/exit. Press E nearby to pick up.', sprite: { sx: 0, sy: 64, sw: 16, sh: 16 } }, // Example: using house sprite // Added pickupable: true
            waterPurifier: { name: 'Water Purifier', requires: { wood: 8, stone: 5 }, placeable: true, width: 40, height: 40, description: `Place near sand/water edge. Interact (E) for water.`, sprite: { sx: 48, sy: 64, sw: 16, sh: 16 } }, // Example: using a chest sprite maybe?
            largeSignalFire: { name: 'Signal Fire', requires: { wood: 30, stone: 10 }, placeable: true, width: 64, height: 64, isSignal: true, description: 'Place & keep lit for rescue chance.', sprite: { sx: 16*6, sy: 0, sw: 16, sh: 16 } } // Example: Large fire / brazier?
        };

        // --- Leaderboard Keys ---
         const LEADERBOARD_KEYS = {
             days: 'leaderboard_days',
             items: 'leaderboard_items',
             fish: 'leaderboard_fish'
         };

        // --- Initialization ---
        function initGame() {
             loadSpritesheet(); // Start loading the image
             setupEventListeners();
             generateCraftingButtons();
             prepareGame();
        }

        // --- Load Spritesheet ---
        function loadSpritesheet() {
            spritesheet = new Image();
            spritesheet.onload = () => {
                spritesheetLoaded = true;
                console.log("Spritesheet loaded successfully.");
                // Regenerate inventory UI in case game started before sheet loaded
                if (gameStarted && !gameOver) {
                     updateInventoryUI();
                }
            };
            spritesheet.onerror = () => {
                console.error(`Failed to load spritesheet from ${SPRITESHEET_SRC}! Check path.`);
                spritesheetLoaded = false; // Ensure flag is false on error
            };
            spritesheet.src = SPRITESHEET_SRC;
        }


        function setupEventListeners() {
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
            document.getElementById('close-crafting').addEventListener('click', closeCraftingMenu);
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('restart-button').addEventListener('click', restartGame);
            // Leaderboard Listeners
            document.getElementById('show-leaderboard-button').addEventListener('click', showLeaderboard);
            document.getElementById('close-leaderboard').addEventListener('click', hideLeaderboard);
            // Inventory Navigation Listeners
            invNavLeftButton.addEventListener('click', navigateInventoryLeft);
            invNavRightButton.addEventListener('click', navigateInventoryRight);
            // Canvas Click Listener (for shelter interaction)
            canvas.addEventListener('click', handleCanvasClick);
        }
        function handleKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
            if (!gameStarted || gameOver) return;

            // Prevent movement if inside shelter
            if (player.isInsideShelter) {
                const moveKeys = ['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'];
                if (moveKeys.includes(e.key.toLowerCase())) {
                    return; // Block movement keys
                }
            }

            // Inventory keybinds (1-5)
            if (e.key >= '1' && e.key <= String(VISIBLE_INVENTORY_SLOTS)) {
                const targetAbsoluteIndex = inventoryStartIndex + parseInt(e.key) - 1;
                 if (targetAbsoluteIndex >= 0 && targetAbsoluteIndex < inventory.length) {
                     selectInventorySlot(targetAbsoluteIndex);
                 } else if (inventory.length > 0 && targetAbsoluteIndex >= inventory.length){
                     selectInventorySlot(inventory.length - 1);
                 }
                 return; // Consume the key event
            }
            // Other keys
            if (e.key.toLowerCase() === 'c') { toggleCraftingMenu(); }
            if (e.key === ' ') { e.preventDefault(); useSelectedItem(); }
            if (e.key.toLowerCase() === 'e') { interactWithWorld(); }
        }

        // --- Handle Clicks on Canvas (Shelter Interaction) ---
        function handleCanvasClick(event) {
            if (!gameStarted || gameOver) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            let clickedShelter = false;
            let shelterFound = null;

            // Check if click hit a shelter
            for (const shelter of shelters) {
                if (checkCollision(clickX, clickY, 1, 1, shelter.x, shelter.y, shelter.width, shelter.height)) // Use checkCollision for point vs rect
                {
                    clickedShelter = true;
                    shelterFound = shelter;
                    break;
                }
            }

            if (clickedShelter) {
                // Clicked on a shelter - Handles Enter/Exit
                if (!player.isInsideShelter) { // Enter if not already inside
                    player.isInsideShelter = shelterFound; // Store reference to the shelter entered
                    player.alpha = 0.4; // Make player semi-transparent
                    showMessage("Entered shelter. Click outside or on shelter again to exit.", 3000);
                    // Snap player position slightly for visual cue (optional)
                    player.x = shelterFound.x + shelterFound.width / 2 - player.width / 2;
                    player.y = shelterFound.y + shelterFound.height / 2 - player.height / 2;
                    hideInteractionPrompt(); // Hide other prompts when entering
                } else if (player.isInsideShelter === shelterFound) {
                     // Clicked the same shelter they are already in - treat as exit
                    player.isInsideShelter = false;
                    player.alpha = 1.0; // Restore full opacity
                    showMessage("Exited shelter.", 2000);
                } else {
                    // Clicked a *different* shelter while already inside one - exit current first
                    player.isInsideShelter = false;
                    player.alpha = 1.0;
                     showMessage("Exited previous shelter.", 1500);
                     // Optional: auto-enter the new one on the same click? Might be confusing.
                     // Require a second click on the new shelter to enter it.
                }
            } else {
                // Clicked outside any shelter
                if (player.isInsideShelter) { // Exit if currently inside
                    player.isInsideShelter = false;
                    player.alpha = 1.0; // Restore full opacity
                    showMessage("Exited shelter.", 2000);
                }
            }
        }


        // --- Modified Inventory Setup ---
        function generateInventorySlots() {
            inventorySlotsContainer.innerHTML = ''; // Clear only the slots container
            for (let i = 0; i < VISIBLE_INVENTORY_SLOTS; i++) {
                const slot = document.createElement('div');
                slot.classList.add('inventory-slot');
                slot.dataset.visibleIndex = i; // Store the visible index (0-4)
                slot.addEventListener('click', (e) => {
                    // Allow clicking slots even if inside shelter
                    const visibleIdx = parseInt(e.currentTarget.dataset.visibleIndex);
                    const actualIndex = inventoryStartIndex + visibleIdx;
                    if (actualIndex < inventory.length) {
                       selectInventorySlot(actualIndex);
                    }
                    e.stopPropagation(); // Prevent inventory click from triggering canvas click (exit shelter)
                });
                inventorySlotsContainer.appendChild(slot);
            }
            updateInventoryUI(); // Initial population and button state update
        }

        function generateCraftingButtons() { const panel = document.getElementById('crafting-panel'); panel.querySelectorAll('.craft-button').forEach(btn => btn.remove()); for (const itemId in craftableItems) { const item = craftableItems[itemId]; const button = document.createElement('button'); button.classList.add('craft-button'); button.dataset.item = itemId; let reqText = Object.entries(item.requires).map(([res, count]) => `${count} ${resources[res]?.name || res}`).join(', '); button.innerHTML = `${item.name}<span class="craft-req">(${reqText})</span><span class="craft-req">${item.description}</span>`; button.addEventListener('click', craftItem); panel.insertBefore(button, document.getElementById('close-crafting')); } }
        function prepareGame() { resetGameState(); document.getElementById('title-screen').style.display = 'flex'; gameOverScreen.style.display = 'none'; }
        function startGame() { document.getElementById('title-screen').style.display = 'none'; gameStarted = true; showMessage("Washed ashore... Need food, water, and shelter. Gather resources (E) and check crafting (C).", 6000); lastTime = performance.now(); requestAnimationFrame(gameLoop); }
        function restartGame() { prepareGame(); }

        function resetGameState() {
            gameStarted = false; gameOver = false; rescued = false;
            // Initialize player object here
             player = {
                x: WORLD_WIDTH / 2,
                y: WORLD_HEIGHT / 2,
                width: TILE_SIZE, // Use TILE_SIZE for consistency
                height: TILE_SIZE, // Use TILE_SIZE for consistency
                speed: 3, // Adjust this value to change movement speed (lower = slower, higher = faster)
                interactionRange: TILE_SIZE * 1.5, // Use TILE_SIZE base
                direction: 'down', // Initial facing direction
                isInsideShelter: false, // Initialize shelter flag (false means not inside)
                alpha: 1.0 // Visual transparency
            };
            // Reset stats including counters
            stats = {
                health: MAX_STAT, hunger: MAX_STAT, thirst: MAX_STAT, day: 1,
                totalItemsCollected: 0,
                fishCaught: 0
            };
            // Initialize empty inventory and reset view
            inventory = [];
            selectedSlot = 0;
            inventoryStartIndex = 0;
            time = { current: 0, dayLength: 120, isNight: false, nightStartFactor: 0.6, dayStartFactor: 0.1 };
            world = []; trees = []; rocks = []; bambooStands = [];
            campfires = []; shelters = []; waterFilters = []; signalFires = [];
            keys = {};
            grassPatches = []; // Reset grass patches
            hintFlags = { firstStone: false, nightWarning: false, lowHealth: false, lowHunger: false, lowThirst: false, shelterPlaced: false, purifierPlaced: false };
            generateWorld(); // Regenerate world (terrain, resources etc.)
            generateInventorySlots(); // Regenerate UI slots and apply initial state
            updateStatsUI(); updateDayNightIndicator();
            closeCraftingMenu(); hideInteractionPrompt(); hideTooltip();
            hideLeaderboard(); // Ensure leaderboard is hidden
            clearTimeout(messageTimeout); messageBox.style.display = 'none';
        }

        function generateGrassPatches() {
            grassPatches = []; // Clear any old patches
            const numPatches = 500; // Reduced slightly for potentially smaller grass area
            const patchSizeBase = TILE_SIZE / 3;
            for (let i = 0; i < numPatches; i++) {
                const tileX = Math.floor(Math.random() * WORLD_WIDTH_TILES);
                const tileY = Math.floor(Math.random() * WORLD_HEIGHT_TILES);
                // Ensure patch only generates on actual grass tiles within the world array
                if (world[tileY] && world[tileY][tileX] === TERRAIN_GRASS) {
                    const px = tileX * TILE_SIZE + Math.random() * TILE_SIZE;
                    const py = tileY * TILE_SIZE + Math.random() * TILE_SIZE;
                    const patchW = patchSizeBase * (0.5 + Math.random());
                    const patchH = patchSizeBase * (0.5 + Math.random());
                    grassPatches.push({ x: px, y: py, w: patchW, h: patchH });
                }
            }
        }

        // ============================================
        // ===== UPDATED generateWorld FUNCTION =====
        // ============================================
        function generateWorld() {
            // 1. Initialize world grid with water
            world = Array(WORLD_HEIGHT_TILES).fill(0).map(() => Array(WORLD_WIDTH_TILES).fill(TERRAIN_WATER));

            // 2. Define island boundaries (adjust these for different shapes)
            const islandMarginX = 3; // Tiles from edge for water
            const islandMarginY = 2;
            const islandMinX = islandMarginX;
            const islandMaxX = WORLD_WIDTH_TILES - 1 - islandMarginX;
            const islandMinY = islandMarginY;
            const islandMaxY = WORLD_HEIGHT_TILES - 1 - islandMarginY;

            // 3. Create main island shape (irregular rectangle for now)
            for (let y = islandMinY; y <= islandMaxY; y++) {
                for (let x = islandMinX; x <= islandMaxX; x++) {
                    // Add some randomness for a less perfect shape
                    const noise = Math.random();
                    if (noise < 0.95 || // Most tiles are land
                        (x > islandMinX + 1 && x < islandMaxX - 1 && y > islandMinY + 1 && y < islandMaxY - 1)) // Inner core is always land
                    {
                        world[y][x] = TERRAIN_SAND; // Start with sand
                    }
                }
            }

            // 4. Define grass area within the sand island
            const grassMargin = 2; // Tiles inside the sand border
            const grassMinX = islandMinX + grassMargin;
            const grassMaxX = islandMaxX - grassMargin;
            const grassMinY = islandMinY + grassMargin;
            const grassMaxY = islandMaxY - grassMargin;

            for (let y = grassMinY; y <= grassMaxY; y++) {
                for (let x = grassMinX; x <= grassMaxX; x++) {
                    if (world[y][x] === TERRAIN_SAND) { // Only convert existing sand to grass
                        // Add slight randomness to grass edges
                        const grassNoise = Math.random();
                        if (grassNoise < 0.85 || (x > grassMinX + 1 && x < grassMaxX - 1 && y > grassMinY + 1 && y < grassMaxY - 1)) {
                           world[y][x] = TERRAIN_GRASS;
                        }
                    }
                }
            }

             // 5. Generate static grass patches on top of the grass terrain
            generateGrassPatches();

            // 6. Player Spawn (Ensure spawn on land, preferably grass)
            let spawnTileX = -1, spawnTileY = -1;
            let attempts = 0;
            while(attempts < 100 && (spawnTileX === -1 || world[spawnTileY]?.[spawnTileX] === TERRAIN_WATER)) {
                spawnTileX = Math.floor(grassMinX + Math.random() * (grassMaxX - grassMinX + 1));
                spawnTileY = Math.floor(grassMinY + Math.random() * (grassMaxY - grassMinY + 1));
                if (world[spawnTileY]?.[spawnTileX] === TERRAIN_GRASS) {
                    break; // Found grass spawn
                }
                 if (world[spawnTileY]?.[spawnTileX] === TERRAIN_SAND && attempts > 50) {
                     break; // Accept sand spawn if grass fails
                 }
                attempts++;
            }
             // Failsafe spawn if random placement failed
             if (spawnTileX === -1 || world[spawnTileY]?.[spawnTileX] === TERRAIN_WATER) {
                 for (let y = islandMinY; y <= islandMaxY; y++) {
                     for (let x = islandMinX; x <= islandMaxX; x++) {
                         if(world[y][x] === TERRAIN_GRASS || world[y][x] === TERRAIN_SAND) {
                             spawnTileX = x;
                             spawnTileY = y;
                             break;
                         }
                     }
                     if (spawnTileX !== -1) break;
                 }
             }
             // Final Failsafe
             if (spawnTileX === -1) { spawnTileX = Math.floor(WORLD_WIDTH_TILES / 2); spawnTileY = Math.floor(WORLD_HEIGHT_TILES / 2); }

             player.x = spawnTileX * TILE_SIZE + TILE_SIZE / 2 - player.width / 2;
             player.y = spawnTileY * TILE_SIZE + TILE_SIZE / 2 - player.height / 2;


            // 7. Resource Placement (Ensure spawning on valid land tiles)
            const numTrees = 45; // Slightly fewer trees for potentially smaller land mass
            const numRocks = 8;
            const numBambooStands = 18;
            const treeRegrowTimeSeconds = TREE_REGROW_DAYS * time.dayLength;
            const bambooRegrowTimeSeconds = BAMBOO_REGROW_DAYS * time.dayLength;

            // Helper to check if a tile is valid land (grass or sand)
            const isLandTile = (tx, ty) => {
                const tileType = world[ty]?.[tx];
                return tileType === TERRAIN_GRASS || tileType === TERRAIN_SAND;
            };
             // Helper to check if a tile is grass
            const isGrassTile = (tx, ty) => world[ty]?.[tx] === TERRAIN_GRASS;

             // Modified canPlace to check for land tiles and avoid water
            const canPlace = (px, py, w, h, checkDist = 50) => {
                 const tileX = Math.floor((px + w / 2) / TILE_SIZE);
                 const tileY = Math.floor((py + h / 2) / TILE_SIZE);

                 // MUST be on a land tile
                 if (!isLandTile(tileX, tileY)) return false;
                 // Resources like Trees/Bamboo typically only on Grass (Rocks might be ok on Sand)
                 // Let's require grass for Trees/Bamboo for now.
                 if (!isGrassTile(tileX, tileY) && !(rocks.length > 0 && rocks.length === rocksPlaced)) { // Allow rocks on sand potentially
                      if (!isGrassTile(tileX, tileY)) return false;
                 }


                 // Avoid spawning too close to the absolute edge of the map (might be water)
                 if (tileX < 1 || tileX >= WORLD_WIDTH_TILES - 1 || tileY < 1 || tileY >= WORLD_HEIGHT_TILES - 1) return false;

                 // Avoid spawning too close to player start
                 const spawnPointX = player.x; const spawnPointY = player.y;
                 if (dist(px + w/2, py + h/2, spawnPointX + player.width/2, spawnPointY + player.height/2) < TILE_SIZE * 4) return false; // Increased distance from spawn

                 // Avoid spawning too close to other resources
                 const allObstacles = [...trees, ...rocks, ...bambooStands];
                 for (const obs of allObstacles) {
                     if (dist(px + w/2, py + h/2, obs.x + obs.width/2, obs.y + obs.height/2) < TILE_SIZE * 1.2) return false; // Slightly increased spacing
                 }
                 return true;
            }

            // Place Trees (Primarily on Grass)
            let treesPlaced = 0; attempts = 0;
            while(treesPlaced < numTrees && attempts < numTrees * 25) { // Increased attempts
                const treeW = TILE_SIZE * 1.5, treeH = TILE_SIZE * 2;
                // Try placing anywhere on the island first
                const tileX = Math.floor(islandMinX + Math.random() * (islandMaxX - islandMinX + 1));
                const tileY = Math.floor(islandMinY + Math.random() * (islandMaxY - islandMinY + 1));

                if (isGrassTile(tileX, tileY)) { // Prefer grass
                    let x = tileX * TILE_SIZE + (Math.random() - 0.5) * TILE_SIZE * 0.5;
                    let y = tileY * TILE_SIZE + (Math.random() - 0.5) * TILE_SIZE * 0.5;
                    if (canPlace(x, y, treeW, treeH, TILE_SIZE * 1.5)) {
                        trees.push({ x, y, width: treeW, height: treeH, health: 3, maxHealth: 3, regrowTimer: 0, regrowTime: treeRegrowTimeSeconds });
                        treesPlaced++;
                    }
                }
                attempts++;
            } if(treesPlaced < numTrees) console.warn(`Only placed ${treesPlaced}/${numTrees} trees.`);

             // Place Rocks (Can be on Grass or Sand, avoid water)
             let rocksPlaced = 0; attempts = 0;
             while(rocksPlaced < numRocks && attempts < numRocks * 40) { // Increased attempts
                 const rockW = TILE_SIZE, rockH = TILE_SIZE;
                 const tileX = Math.floor(islandMinX + Math.random() * (islandMaxX - islandMinX + 1));
                 const tileY = Math.floor(islandMinY + Math.random() * (islandMaxY - islandMinY + 1));

                 if (isLandTile(tileX, tileY)) { // Must be on land
                     let x = tileX * TILE_SIZE + Math.random() * TILE_SIZE * 0.5;
                     let y = tileY * TILE_SIZE + Math.random() * TILE_SIZE * 0.5;
                     if (canPlace(x, y, rockW, rockH, TILE_SIZE * 1.5)) {
                         rocks.push({ x, y, width: rockW, height: rockH, health: 4, maxHealth: 4 });
                         rocksPlaced++;
                     }
                 }
                 attempts++;
             } if(rocksPlaced < numRocks) console.warn(`Only placed ${rocksPlaced}/${numRocks} rocks.`);

             // Place Bamboo (Primarily on Grass)
              let bambooPlaced = 0; attempts = 0;
              while(bambooPlaced < numBambooStands && attempts < numBambooStands * 30) { // Increased attempts
                  const bambooW = TILE_SIZE * 0.8, bambooH = TILE_SIZE * 1.2;
                  const tileX = Math.floor(islandMinX + Math.random() * (islandMaxX - islandMinX + 1));
                  const tileY = Math.floor(islandMinY + Math.random() * (islandMaxY - islandMinY + 1));

                  if (isGrassTile(tileX, tileY)) { // Prefer grass
                       let x = tileX * TILE_SIZE + Math.random() * TILE_SIZE * 0.5;
                       let y = tileY * TILE_SIZE + Math.random() * TILE_SIZE * 0.5;
                      if (canPlace(x, y, bambooW, bambooH, TILE_SIZE)) {
                          bambooStands.push({ x, y, width: bambooW, height: bambooH, health: BAMBOO_HEALTH, maxHealth: BAMBOO_HEALTH, regrowTimer: 0, regrowTime: bambooRegrowTimeSeconds });
                          bambooPlaced++;
                      }
                  }
                  attempts++;
              } if(bambooPlaced < numBambooStands) console.warn(`Only placed ${bambooPlaced}/${numBambooStands} bamboo stands.`);
        }
        // ============================================
        // === END UPDATED generateWorld FUNCTION ===
        // ============================================


        // --- Game Loop ---
        let lastTime = 0;
        function gameLoop(currentTime) { if (!gameStarted || gameOver) return; const deltaTime = (currentTime - lastTime) / 1000; lastTime = currentTime; update(deltaTime); render(); requestAnimationFrame(gameLoop); }

        // --- Update Functions ---
        function update(deltaTime) {
            updateTime(deltaTime);
            updatePlayerMovement(deltaTime);
            updateWorldInteractions(deltaTime); // Handle interaction prompts
            updateResources(deltaTime);
            updateStats(deltaTime);
            updateSignalFires(deltaTime);
            checkGameOver();
        }
        function updateTime(deltaTime) { let previousDay = stats.day; time.current = (time.current + deltaTime); if (time.current >= time.dayLength) { time.current %= time.dayLength; stats.day++; hintFlags.nightWarning = false; showMessage(`Day ${stats.day} has begun.`); } const timeOfDay = time.current / time.dayLength; time.isNight = timeOfDay >= time.nightStartFactor || timeOfDay < time.dayStartFactor; updateDayNightIndicator(); updateStatsUI(); if (!hintFlags.nightWarning && timeOfDay > (time.nightStartFactor - 0.1) && timeOfDay < time.nightStartFactor) { showMessage("Sun is setting. It might get cold. Consider fire or shelter.", 5000); hintFlags.nightWarning = true; } }

        function updatePlayerMovement(deltaTime) {
            if (player.isInsideShelter) return; // Don't move if inside shelter
            let dx = 0; let dy = 0;
            const currentSpeed = player.speed * TILE_SIZE * deltaTime;
            if (keys['w'] || keys['arrowup']) { dy -= currentSpeed; player.direction = 'up'; }
            if (keys['s'] || keys['arrowdown']) { dy += currentSpeed; player.direction = 'down'; }
            if (keys['a'] || keys['arrowleft']) { dx -= currentSpeed; player.direction = 'left'; }
            if (keys['d'] || keys['arrowright']) { dx += currentSpeed; player.direction = 'right'; }
            if (dx === 0 && dy === 0) return;

            let nextX = player.x + dx;
            let nextY = player.y + dy;

            // Basic World Boundary Check (keep player within canvas)
            if (nextX < 0) nextX = 0;
            if (nextY < 0) nextY = 0;
            if (nextX + player.width > WORLD_WIDTH) nextX = WORLD_WIDTH - player.width;
            if (nextY + player.height > WORLD_HEIGHT) nextY = WORLD_HEIGHT - player.height;

            // --- Collision Detection ---
            let collisionX = false;
            let collisionY = false;

            // 1. Terrain Collision (Water)
            const nextPlayerRect = { x: nextX, y: nextY, width: player.width, height: player.height };
            const cornerCheckMargin = TILE_SIZE * 0.2; // Check slightly inside corners

             // Check X movement collision
            const nextPlayerRectX = { x: nextX, y: player.y, width: player.width, height: player.height };
             const cornersX = [
                 { x: nextPlayerRectX.x + cornerCheckMargin, y: nextPlayerRectX.y + cornerCheckMargin },
                 { x: nextPlayerRectX.x + nextPlayerRectX.width - cornerCheckMargin, y: nextPlayerRectX.y + cornerCheckMargin },
                 { x: nextPlayerRectX.x + cornerCheckMargin, y: nextPlayerRectX.y + nextPlayerRectX.height - cornerCheckMargin },
                 { x: nextPlayerRectX.x + nextPlayerRectX.width - cornerCheckMargin, y: nextPlayerRectX.y + nextPlayerRectX.height - cornerCheckMargin }
             ];
            for (const corner of cornersX) {
                const tileX = Math.floor(corner.x / TILE_SIZE);
                const tileY = Math.floor(corner.y / TILE_SIZE);
                if (world[tileY]?.[tileX] === TERRAIN_WATER) {
                    collisionX = true;
                    // Snap back based on movement direction
                    if (dx > 0) nextX = tileX * TILE_SIZE - player.width;
                    else if (dx < 0) nextX = (tileX + 1) * TILE_SIZE;
                    break;
                }
            }

             // Check Y movement collision
             const nextPlayerRectY = { x: player.x, y: nextY, width: player.width, height: player.height };
             const cornersY = [
                  { x: nextPlayerRectY.x + cornerCheckMargin, y: nextPlayerRectY.y + cornerCheckMargin },
                  { x: nextPlayerRectY.x + nextPlayerRectY.width - cornerCheckMargin, y: nextPlayerRectY.y + cornerCheckMargin },
                  { x: nextPlayerRectY.x + cornerCheckMargin, y: nextPlayerRectY.y + nextPlayerRectY.height - cornerCheckMargin },
                  { x: nextPlayerRectY.x + nextPlayerRectY.width - cornerCheckMargin, y: nextPlayerRectY.y + nextPlayerRectY.height - cornerCheckMargin }
             ];
            for (const corner of cornersY) {
                const tileX = Math.floor(corner.x / TILE_SIZE);
                const tileY = Math.floor(corner.y / TILE_SIZE);
                 if (world[tileY]?.[tileX] === TERRAIN_WATER) {
                    collisionY = true;
                     // Snap back based on movement direction
                    if (dy > 0) nextY = tileY * TILE_SIZE - player.height;
                    else if (dy < 0) nextY = (tileY + 1) * TILE_SIZE;
                    break;
                }
            }


            // 2. Obstacle Collision (Trees, Rocks, Placed Items - EXCLUDING shelters for movement)
            const obstacles = [ ...trees.filter(t => t.health > 0), ...rocks.filter(r => r.health > 0), ...bambooStands.filter(b => b.health > 0), ...campfires, ...waterFilters, ...signalFires ]; // Removed shelters from movement collision
            for (const obj of obstacles) {
                // Check X collision separately
                if (!collisionX && checkCollision(nextX, player.y, player.width, player.height, obj.x, obj.y, obj.width, obj.height)) {
                    collisionX = true;
                    // Adjust nextX based on collision side
                    if (dx > 0) nextX = obj.x - player.width; // Moving right, hit left side of obstacle
                    else if (dx < 0) nextX = obj.x + obj.width; // Moving left, hit right side of obstacle
                }
                // Check Y collision separately
                if (!collisionY && checkCollision(player.x, nextY, player.width, player.height, obj.x, obj.y, obj.width, obj.height)) {
                    collisionY = true;
                     // Adjust nextY based on collision side
                    if (dy > 0) nextY = obj.y - player.height; // Moving down, hit top side of obstacle
                    else if (dy < 0) nextY = obj.y + obj.height; // Moving up, hit bottom side of obstacle
                }
            }
             // Add shelter collision check separately AFTER other obstacles
             for (const shelter of shelters) {
                 // Only collide if the player is NOT inside this specific shelter
                 if (player.isInsideShelter !== shelter) {
                      // Check X collision separately
                      if (!collisionX && checkCollision(nextX, player.y, player.width, player.height, shelter.x, shelter.y, shelter.width, shelter.height)) {
                          collisionX = true;
                          if (dx > 0) nextX = shelter.x - player.width;
                          else if (dx < 0) nextX = shelter.x + shelter.width;
                      }
                      // Check Y collision separately
                      if (!collisionY && checkCollision(player.x, nextY, player.width, player.height, shelter.x, shelter.y, shelter.width, shelter.height)) {
                          collisionY = true;
                          if (dy > 0) nextY = shelter.y - player.height;
                          else if (dy < 0) nextY = shelter.y + shelter.height;
                      }
                 }
            }


            // Final Boundary check after collision adjustments
            if (nextX < 0) nextX = 0;
            if (nextY < 0) nextY = 0;
            if (nextX + player.width > WORLD_WIDTH) nextX = WORLD_WIDTH - player.width;
            if (nextY + player.height > WORLD_HEIGHT) nextY = WORLD_HEIGHT - player.height;

            // Update player position if no collision occurred on that axis
            if (!collisionX) player.x = nextX;
            if (!collisionY) player.y = nextY;
        }


        // ==================================================
        // ===== UPDATED updateWorldInteractions FUNCTION =====
        // ==================================================
        function updateWorldInteractions(deltaTime) {
            if (player.isInsideShelter) { // No interactions possible while inside shelter
                 hideInteractionPrompt();
                 return;
             }

            const interactionPoint = getInteractionPoint(); let promptShown = false;
            const iP = interactionPoint; // Alias for brevity
             const iTX = Math.floor(iP.x / TILE_SIZE);
             const iTY = Math.floor(iP.y / TILE_SIZE);
             const targetTile = world[iTY]?.[iTX];
             const playerCX = player.x + player.width / 2;
             const playerCY = player.y + player.height / 2;

             // Interaction Priority Order:
             // 1. Use Placed Objects (Purifier, Signal Fire Fuel)
             // 2. Gather Resources (Trees, Rocks, Bamboo)
             // 3. Water Actions (Fish / Drink)
             // 4. Pick Up Shelter (Lowest priority)

            // 1. Use Placed Objects
            // Water Purifier
            for (const purifier of waterFilters) { if (dist(iP.x, iP.y, purifier.x + purifier.width / 2, purifier.y + purifier.height / 2) < player.interactionRange) { showInteractionPrompt("Press E to Use Water Purifier"); promptShown = true; break; } }
            if (promptShown) return;
            // Signal Fire (Adding Fuel)
            for (const fire of signalFires) { if (dist(iP.x, iP.y, fire.x + fire.width / 2, fire.y + fire.height / 2) < player.interactionRange) { const selectedItem = inventory[selectedSlot]; if (selectedItem && selectedItem.item === 'wood' && selectedItem.count > 0) { showInteractionPrompt(`Press E to Add Wood (Fuel: ${Math.ceil(fire.fuel)}/${fire.maxFuel})`); } else if (fire.isBurning) { showInteractionPrompt(`Signal Fire (Fuel: ${Math.ceil(fire.fuel)}/${fire.maxFuel})`); } else { showInteractionPrompt(`Signal Fire (Needs Wood - Select Wood and press E)`); } promptShown = true; break; } }
            if (promptShown) return;

             // 2. Gather Resources
             const interactableResources = [...trees.filter(t=>t.health>0), ...rocks.filter(r=>r.health>0), ...bambooStands.filter(b=>b.health>0)]
                 .filter(r => dist(iP.x, iP.y, r.x + r.width / 2, r.y + r.height / 2) < player.interactionRange + 10) // Check if resource center is near interaction point
                 .sort((a, b) => dist(playerCX, playerCY, a.x + a.width / 2, a.y + a.height / 2) - dist(playerCX, playerCY, b.x + b.width / 2, b.y + b.height / 2)); // Sort by distance to player center
             if (interactableResources.length > 0) { const targetResource = interactableResources[0]; if (trees.includes(targetResource)) { showInteractionPrompt("Press E to Chop Tree"); } else if (rocks.includes(targetResource)) { showInteractionPrompt("Press E to Mine Rock"); } else if (bambooStands.includes(targetResource)) { showInteractionPrompt("Press E to Cut Bamboo"); } promptShown = true; }
             if (promptShown) return;

            // 3. Water Interaction
            let isNearWater = targetTile === TERRAIN_WATER;
            if (!isNearWater && (targetTile === TERRAIN_SAND || targetTile === TERRAIN_GRASS)) { // Check adjacent only if on land
                 const adjacent = [{x:iTX, y:iTY-1}, {x:iTX, y:iTY+1}, {x:iTX-1, y:iTY}, {x:iTX+1, y:iTY}];
                 for (const adj of adjacent) { if (world[adj.y]?.[adj.x] === TERRAIN_WATER) { isNearWater = true; break; } }
            }
             if (isNearWater) {
                 const hasRod = inventory.some(s => s && s.item === 'fishingRod');
                 let promptText = "Press E to "; let canDoSomething = false;
                 if (hasRod) { promptText += "Fish"; canDoSomething = true; }
                 if (canDoSomething) promptText += " / ";
                 promptText += "Drink Dirty Water";
                 showInteractionPrompt(promptText); promptShown = true;
             }
             if (promptShown) return;

             // 4. Pick Up Shelter (Only if no other interaction applies)
             const nearbyShelters = shelters
                 .filter(s => dist(iP.x, iP.y, s.x + s.width / 2, s.y + s.height / 2) < player.interactionRange + 10) // Check near interaction point
                 .sort((a, b) => dist(playerCX, playerCY, a.x + a.width / 2, a.y + a.height / 2) - dist(playerCX, playerCY, b.x + b.width / 2, b.y + b.height / 2)); // Sort by distance to player

             if (nearbyShelters.length > 0) {
                 const shelterDef = craftableItems['shelter'];
                 if (shelterDef && shelterDef.pickupable) {
                     showInteractionPrompt("Press E to Pick Up Shelter");
                     promptShown = true;
                 }
             }

            // If no prompts were shown, hide the prompt area
            if (!promptShown) { hideInteractionPrompt(); }
        }
        // ==================================================
        // === END UPDATED updateWorldInteractions FUNCTION ===
        // ==================================================

        function updateResources(deltaTime) { trees.forEach(t => { if (t.health <= 0) { t.regrowTimer += deltaTime; if (t.regrowTimer >= t.regrowTime) { t.health = t.maxHealth; t.regrowTimer = 0; } } }); bambooStands.forEach(b => { if (b.health <= 0) { b.regrowTimer += deltaTime; if (b.regrowTimer >= b.regrowTime) { b.health = b.maxHealth; b.regrowTimer = 0; } } }); }
        function updateStats(deltaTime) {
            const hR = 0.5, tR = 0.75; const sD = 2.0, dD = 2.5, nCD = 1.5; const shelterHungerFactor = 0.3; const shelterThirstFactor = 0.3;
            let currentHungerRate = hR; let currentThirstRate = tR; let coldDamageRate = nCD;
            const inS = !!player.isInsideShelter;
            if (inS) { currentHungerRate *= shelterHungerFactor; currentThirstRate *= shelterThirstFactor; coldDamageRate = 0; }
            stats.hunger -= currentHungerRate * deltaTime; stats.thirst -= currentThirstRate * deltaTime;
            let healthChange = 0;
            if(stats.hunger<30&&!hintFlags.lowHunger){showMessage("Feeling hungry. Find food.", 3000); hintFlags.lowHunger=true;} else if(stats.hunger>50)hintFlags.lowHunger=false;
            if(stats.thirst<30&&!hintFlags.lowThirst){showMessage("Very thirsty. Find water.", 3000); hintFlags.lowThirst=true;} else if(stats.thirst>50)hintFlags.lowThirst=false;
            if(stats.health<50&&!hintFlags.lowHealth){showMessage("Health is low!", 3000); hintFlags.lowHealth=true;} else if(stats.health>70)hintFlags.lowHealth=false;
            if(stats.hunger <= 0) healthChange -= sD * deltaTime; if(stats.thirst <= 0) healthChange -= dD * deltaTime;
            const nearCF = !inS && isPlayerNearObject(campfires, TILE_SIZE * 2.5); // Adjusted range check
            const nearSF = !inS && isPlayerNearObject(signalFires.filter(f => f.isBurning), TILE_SIZE * 3); // Adjusted range check
            if (time.isNight && !nearCF && !nearSF && !inS) { healthChange -= coldDamageRate * deltaTime; if(Math.random()<0.03*deltaTime)showMessage("Freezing! Find warmth!", 2000); }
            stats.health += healthChange;
            stats.hunger = Math.max(0, Math.min(MAX_STAT, stats.hunger)); stats.thirst = Math.max(0, Math.min(MAX_STAT, stats.thirst)); stats.health = Math.max(0, Math.min(MAX_STAT, stats.health));
            updateStatsUI();
        }
        function updateSignalFires(deltaTime) { let activeSF = false; signalFires.forEach(f => { if (f.isBurning) { f.fuel -= deltaTime * f.burnRate; if (f.fuel <= 0) { f.isBurning = false; f.fuel = 0; } else { activeSF = true; } } }); if (stats.day >= RESCUE_START_DAY && activeSF && !gameOver) { const chance = BASE_RESCUE_CHANCE * deltaTime / time.dayLength; if (Math.random() < chance) { triggerRescue(); } } }

        // --- Leaderboard Functions ---
        function loadLeaderboard(key) { try { const data = localStorage.getItem(key); return data ? JSON.parse(data) : []; } catch (e) { console.error("Error loading leaderboard:", key, e); return []; } }
        function saveScoreToLeaderboard(key, playerName, scoreValue) { if (!playerName || scoreValue <= 0) return; const leaderboard = loadLeaderboard(key); const newScore = { name: playerName, score: scoreValue, date: new Date().toLocaleDateString() }; leaderboard.push(newScore); leaderboard.sort((a, b) => b.score - a.score); const trimmedLeaderboard = leaderboard.slice(0, LEADERBOARD_MAX_ENTRIES); try { localStorage.setItem(key, JSON.stringify(trimmedLeaderboard)); } catch (e) { console.error("Error saving leaderboard:", key, e); } }
        function doesScoreQualify(key, scoreValue) { if (scoreValue <= 0) return false; const leaderboard = loadLeaderboard(key); if (leaderboard.length < LEADERBOARD_MAX_ENTRIES) return true; return scoreValue > (leaderboard[leaderboard.length - 1]?.score || 0); }
        function checkAndSaveLeaderboardScores() { const finalDays = stats.day; const finalItems = stats.totalItemsCollected; const finalFish = stats.fishCaught; let playerName = "Survivor"; let promptedForName = false; const qualifiesDays = doesScoreQualify(LEADERBOARD_KEYS.days, finalDays); const qualifiesItems = doesScoreQualify(LEADERBOARD_KEYS.items, finalItems); const qualifiesFish = doesScoreQualify(LEADERBOARD_KEYS.fish, finalFish); if (qualifiesDays || qualifiesItems || qualifiesFish) { const nameInput = prompt(`New high score! Enter your name (max 15 chars):`, "Survivor"); if (nameInput) { playerName = nameInput.substring(0, 15).trim() || "Survivor"; promptedForName = true; if (qualifiesDays) saveScoreToLeaderboard(LEADERBOARD_KEYS.days, playerName, finalDays); if (qualifiesItems) saveScoreToLeaderboard(LEADERBOARD_KEYS.items, playerName, finalItems); if (qualifiesFish) saveScoreToLeaderboard(LEADERBOARD_KEYS.fish, playerName, finalFish); } else { console.log("Player cancelled name input."); } } /* Optionally show leaderboard after saving */ }
        function displayLeaderboard() { const populateList = (listElement, data, unit) => { listElement.innerHTML = ''; if (data.length === 0) { listElement.innerHTML = '<li>No scores yet!</li>'; } else { data.forEach((entry, index) => { const li = document.createElement('li'); li.innerHTML = `<span class="rank">${index + 1}.</span> <span class="name">${entry.name}</span> <span class="score">${entry.score} ${unit}</span> <span class="date">${entry.date}</span>`; listElement.appendChild(li); }); }}; populateList(lbDaysList, loadLeaderboard(LEADERBOARD_KEYS.days), "Days"); populateList(lbItemsList, loadLeaderboard(LEADERBOARD_KEYS.items), "Items"); populateList(lbFishList, loadLeaderboard(LEADERBOARD_KEYS.fish), "Fish"); leaderboardPanel.style.display = 'flex'; }
        function showLeaderboard() { displayLeaderboard(); }
        function hideLeaderboard() { leaderboardPanel.style.display = 'none'; }

        // --- Game End Functions ---
        function triggerRescue() { if (gameOver) return; gameStarted = false; gameOver = true; rescued = true; checkAndSaveLeaderboardScores(); showMessage("You hear an airplane overhead! They've spotted your fire!", 5000); setTimeout(() => { gameOverTitle.textContent = "Rescued!"; gameOverTitle.style.color = '#8cc751'; daysSurvivedText.innerHTML = `You survived for ${stats.day} days!<br>Collected ${stats.totalItemsCollected} items.<br>Caught ${stats.fishCaught} fish.`; gameOverScreen.style.display = 'flex'; }, 4000); }
        function checkGameOver() { if (!gameOver && stats.health <= 0) { gameOver = true; gameStarted = false; checkAndSaveLeaderboardScores(); gameOverTitle.textContent = "Game Over"; gameOverTitle.style.color = '#ff4d4d'; daysSurvivedText.innerHTML = `You survived for ${stats.day} days.<br>Collected ${stats.totalItemsCollected} items.<br>Caught ${stats.fishCaught} fish.`; gameOverScreen.style.display = 'flex'; showMessage("You didn't survive...", 5000); } }

        // --- Interaction & Actions ---

        // =============================================
        // ===== UPDATED interactWithWorld FUNCTION =====
        // =============================================
        function interactWithWorld() {
            if (gameOver || player.isInsideShelter) return; // Can't interact while inside shelter
            const iP = getInteractionPoint();
            let interacted = false;
            const selectedItem = inventory[selectedSlot];
            const playerCX = player.x + player.width / 2;
            const playerCY = player.y + player.height / 2;

             // Interaction Priority Order:
             // 1. Use Placed Objects (Purifier, Signal Fire Fuel)
             // 2. Gather Resources (Trees, Rocks, Bamboo)
             // 3. Water Actions (Fish / Drink)
             // 4. Pick Up Shelter (Lowest priority)

             // 1. Add fuel to Signal Fire (if wood selected)
            if(selectedItem && selectedItem.item==='wood'&&selectedItem.count>0){
                for(const f of signalFires){
                     if(dist(iP.x, iP.y, f.x + f.width / 2, f.y + f.height / 2) < player.interactionRange){
                         const fuelToAdd = Math.min(selectedItem.count, 10); // Add up to 10 wood
                         f.fuel = Math.min(f.maxFuel, f.fuel + fuelToAdd * f.fuelPerWood);
                         f.isBurning = true; // Ensure it's burning after adding fuel
                         removeItemFromInventory('wood', fuelToAdd);
                         showMessage(`Added ${fuelToAdd} wood. Fuel: ${Math.ceil(f.fuel)}/${f.maxFuel}`, 2500);
                         interacted = true; break;
                     }
                 }
                 if(interacted) return; // Don't do other actions if fuel was added
            }

             // 1. Use Water Purifier
             for(const p of waterFilters){
                 const pCX = p.x + p.width / 2; const pCY = p.y + p.height / 2;
                 if(dist(iP.x, iP.y, pCX, pCY) < player.interactionRange){
                     stats.thirst = Math.min(MAX_STAT, stats.thirst + 40);
                     stats.health = Math.min(MAX_STAT, stats.health + 2); // Small health boost for clean water
                     showMessage("Used purifier. Drank clean water (+2 Health).", 2000);
                     updateStatsUI();
                     interacted = true; break;
                 }
             }
             if(interacted) return;

            // 2. Gather Resources (Find closest valid resource first)
             const nearbyResources = [...trees.filter(t => t.health > 0), ...rocks.filter(r => r.health > 0), ...bambooStands.filter(b => b.health > 0)]
                 .filter(r => dist(iP.x, iP.y, r.x + r.width / 2, r.y + r.height / 2) < player.interactionRange + 10)
                 .sort((a, b) => dist(playerCX, playerCY, a.x + a.width / 2, a.y + a.height / 2) - dist(playerCX, playerCY, b.x + b.width / 2, b.y + b.height / 2));

             if (nearbyResources.length > 0) {
                 const target = nearbyResources[0];
                 if (trees.includes(target)) {
                     const hasAxe = inventory.some(s => s && s.item === 'axe');
                     let damage = hasAxe ? 1 : 0.25;
                     target.health -= damage;
                     if (target.health <= 0) {
                         addItemToInventory('wood', hasAxe ? 5 : 2);
                         showMessage(`Chopped tree, got ${hasAxe ? 5 : 2} wood.`, 2500);
                         target.health = 0; target.regrowTimer = 0;
                     } else {
                         addItemToInventory('wood', 1); // Get 1 wood per hit before felling
                         showMessage(`Chopped tree (${Math.ceil(target.health)} HP).`, 1500);
                     }
                     interacted = true;
                 } else if (rocks.includes(target)) {
                     const hasPickaxe = false; // Placeholder for potential future pickaxe
                     let damage = hasPickaxe ? 1 : 0.2; // Slower mining without pickaxe
                     target.health -= damage;
                     if (target.health <= 0) {
                         addItemToInventory('stone', 2);
                         showMessage("Broke rock, got 2 stone.", 2500);
                         if (!hintFlags.firstStone) { showMessage("Stone acquired! Useful for tools (Crafting 'C').", 4000); hintFlags.firstStone = true; }
                         rocks.splice(rocks.indexOf(target), 1); // Remove rock permanently
                     } else {
                         if (Math.random() < 0.5) { // Chance to get stone per hit
                             addItemToInventory('stone', 1);
                             showMessage(`Mined rock, got 1 stone (${Math.ceil(target.health)} HP).`, 1500);
                             if (!hintFlags.firstStone) { showMessage("Stone acquired! Useful for tools (Crafting 'C').", 4000); hintFlags.firstStone = true; }
                         } else {
                             showMessage(`Mining rock (${Math.ceil(target.health)} HP).`, 1000);
                         }
                     }
                     interacted = true;
                 } else if (bambooStands.includes(target)) {
                     target.health = 0; // Bamboo cut in one go
                     addItemToInventory('wood', BAMBOO_WOOD_YIELD);
                     showMessage(`Cut bamboo, got ${BAMBOO_WOOD_YIELD} wood.`, 2000);
                     target.regrowTimer = 0;
                     interacted = true;
                 }
             }
             if(interacted) return;

             // 3. Fish or Drink Dirty Water (Check proximity to water)
             const iTX = Math.floor(iP.x / TILE_SIZE);
             const iTY = Math.floor(iP.y / TILE_SIZE);
             let isNearWater = world[iTY]?.[iTX] === TERRAIN_WATER;
             if (!isNearWater) {
                 const adjacent = [{x:iTX, y:iTY-1}, {x:iTX, y:iTY+1}, {x:iTX-1, y:iTY}, {x:iTX+1, y:iTY}];
                 for (const adj of adjacent) { if (world[adj.y]?.[adj.x] === TERRAIN_WATER) { isNearWater = true; break; } }
             }
             if (isNearWater) {
                 const hasRod = inventory.some(s => s && s.item === 'fishingRod');
                 let didAction = false;
                 if (hasRod) {
                     const fishChance = time.isNight ? 0.9 : 0.4;
                     if (Math.random() < fishChance) { if (addItemToInventory('fish', 1)) { showMessage(`Caught a fish!${time.isNight ? ' (Night!)' : ''}`, 2500); stats.fishCaught++; } } else { showMessage("Fishing... no luck.", 2000); }
                     didAction = true;
                 } else {
                     stats.thirst = Math.min(MAX_STAT, stats.thirst + 15);
                     if (Math.random() < 0.3) { stats.health = Math.max(0, stats.health - 10); showMessage("Drank dirty water. Felt unwell (-10 Health).", 2500); } else { showMessage("Drank dirty water. Risky...", 2000); }
                     didAction = true;
                 }
                 if (didAction) { updateStatsUI(); interacted = true; }
             }
            if(interacted) return;

            // 4. Pick Up Shelter
            const nearbyShelters = shelters
                 .filter(s => dist(iP.x, iP.y, s.x + s.width / 2, s.y + s.height / 2) < player.interactionRange + 10)
                 .sort((a, b) => dist(playerCX, playerCY, a.x + a.width / 2, a.y + a.height / 2) - dist(playerCX, playerCY, b.x + b.width / 2, b.y + b.height / 2));

             if (nearbyShelters.length > 0) {
                 const targetShelter = nearbyShelters[0];
                 const shelterDef = craftableItems['shelter'];
                 if (shelterDef && shelterDef.pickupable) {
                     // Attempt to add shelter back to inventory
                     if (addItemToInventory('shelter', 1)) {
                         // Remove from world only if successfully added to inventory
                         const index = shelters.indexOf(targetShelter);
                         if (index > -1) {
                             shelters.splice(index, 1);
                         }
                         showMessage("Picked up Shelter.", 2000);
                         interacted = true;
                     } else {
                         // Inventory was full
                         showMessage("Cannot pick up shelter, inventory full!", 2500);
                         interacted = true; // Still counts as an interaction attempt
                     }
                 }
             }
             // No return needed here, function ends if no interaction happened
        }
        // =============================================
        // === END UPDATED interactWithWorld FUNCTION ===
        // =============================================

        function useSelectedItem() {
             if (gameOver || player.isInsideShelter) return;
             const selected = inventory[selectedSlot];
             if (!selected || selected.item === 'none' || selected.count <= 0) return;
             const itemName = selected.item;

             // 1. Consumable Items (Food)
             if (resources[itemName] && (resources[itemName].restoresHunger || resources[itemName].heals)) {
                 stats.hunger = Math.min(MAX_STAT, stats.hunger + (resources[itemName].restoresHunger || 0));
                 stats.health = Math.min(MAX_STAT, stats.health + (resources[itemName].heals || 0));
                 removeItemFromInventory(itemName, 1);
                 showMessage(`Ate ${resources[itemName].name}. ${resources[itemName].heals > 0 ? `(+${resources[itemName].heals}H)` : ''}`, 2000);
                 updateStatsUI();
                 return; // Action completed
             }

             // 2. Placeable Items
              if (craftableItems[itemName] && craftableItems[itemName].placeable) {
                 const itemData = craftableItems[itemName];
                 const placeW = itemData.width;
                 const placeH = itemData.height;

                 // Determine placement position based on player facing direction
                 let placeX = player.x + player.width / 2 - placeW / 2; // Center horizontally initially
                 let placeY;
                 const placementDist = TILE_SIZE * 0.3; // How far in front to place

                 switch(player.direction) {
                     case 'up':    placeY = player.y - placeH - placementDist; break;
                     case 'down':  placeY = player.y + player.height + placementDist; break;
                     case 'left':  placeX = player.x - placeW - placementDist; placeY = player.y + player.height / 2 - placeH / 2; break;
                     case 'right': placeX = player.x + player.width + placementDist; placeY = player.y + player.height / 2 - placeH / 2; break;
                     default:      placeY = player.y + player.height + placementDist; // Default to down
                 }

                 let canPlace = true;
                 const placeRect = { x: placeX, y: placeY, width: placeW, height: placeH };
                 const placeCenterX = placeX + placeW / 2;
                 const placeCenterY = placeY + placeH / 2;
                 const placeTileX = Math.floor(placeCenterX / TILE_SIZE);
                 const placeTileY = Math.floor(placeCenterY / TILE_SIZE);
                 const targetTileType = world[placeTileY]?.[placeTileX];

                 // --- Placement Rules ---
                 // General: Cannot place outside world bounds
                 if (placeX < 0 || placeY < 0 || placeX + placeW > WORLD_WIDTH || placeY + placeH > WORLD_HEIGHT) {
                     showMessage("Cannot place outside the island bounds.", 2000);
                     canPlace = false;
                 }
                 // General: Cannot place in Water
                 if (canPlace && targetTileType === TERRAIN_WATER) {
                      showMessage("Cannot place in water.", 2000);
                      canPlace = false;
                 }
                 // General: Cannot place if colliding with existing objects (including other shelters now)
                 if (canPlace) {
                     const allObstacles = [...trees.filter(t => t.health > 0), ...rocks.filter(r => r.health > 0), ...bambooStands.filter(b => b.health > 0), ...campfires, ...shelters, ...waterFilters, ...signalFires, player]; // Include player
                     for (const obj of allObstacles) {
                         if (checkCollision(placeRect.x, placeRect.y, placeRect.width, placeRect.height, obj.x, obj.y, obj.width, obj.height)) {
                             showMessage("Cannot place here (Obstacle).", 2000);
                             canPlace = false;
                             break;
                         }
                     }
                 }
                 // Specific: Water Purifier Rules
                 if (canPlace && itemName === 'waterPurifier') {
                      // Must be placed on Grass or Sand
                     if (targetTileType !== TERRAIN_GRASS && targetTileType !== TERRAIN_SAND) {
                         showMessage("Purifier must be placed on land (Grass or Sand).", 2500);
                         canPlace = false;
                     }
                      // Must be near water (or sand adjacent to water)
                     if (canPlace) {
                         let nearWaterSource = false;
                         const checkRadiusTiles = 2; // Check 2 tiles around placement center
                         const minCheckX = Math.max(0, placeTileX - checkRadiusTiles);
                         const maxCheckX = Math.min(WORLD_WIDTH_TILES - 1, placeTileX + checkRadiusTiles);
                         const minCheckY = Math.max(0, placeTileY - checkRadiusTiles);
                         const maxCheckY = Math.min(WORLD_HEIGHT_TILES - 1, placeTileY + checkRadiusTiles);

                         for (let ty = minCheckY; ty <= maxCheckY; ty++) {
                             for (let tx = minCheckX; tx <= maxCheckX; tx++) {
                                 if (world[ty]?.[tx] === TERRAIN_WATER) { nearWaterSource = true; break; }
                                 if (world[ty]?.[tx] === TERRAIN_SAND) { const adj = [{x:tx, y:ty-1}, {x:tx, y:ty+1}, {x:tx-1, y:ty}, {x:tx+1, y:ty}]; for(const a of adj) { if(world[a.y]?.[a.x] === TERRAIN_WATER) { nearWaterSource = true; break; } } }
                                 if (nearWaterSource) break;
                             }
                              if (nearWaterSource) break;
                         }
                         if (!nearWaterSource) { showMessage(`Place purifier closer to water.`, 2500); canPlace = false; }
                     }
                 }
                  // Specific: Most other items require Grass (allow shelter, campfire, signal on sand)
                 else if (canPlace && targetTileType !== TERRAIN_GRASS) {
                      const allowedOnSand = ['shelter', 'campfire', 'largeSignalFire'];
                      if (!allowedOnSand.includes(itemName) || targetTileType !== TERRAIN_SAND) {
                           showMessage(`Cannot place ${itemData.name} on ${targetTileType || 'water'}. Needs grass${allowedOnSand.includes(itemName) ? ' or sand' : ''}.`, 2000);
                           canPlace = false;
                      }
                 }


                 // --- Execute Placement ---
                 if (canPlace) {
                     const newObject = { x: placeX, y: placeY, width: placeW, height: placeH };
                     let itemPlaced = false;

                     if (itemData.isSignal) { newObject.isBurning = false; newObject.fuel = 0; newObject.maxFuel = 100; newObject.fuelPerWood = 5; newObject.burnRate = 0.5; signalFires.push(newObject); itemPlaced = true; }
                     else if (itemName === 'campfire') { campfires.push(newObject); itemPlaced = true; }
                     else if (itemName === 'shelter') { shelters.push(newObject); itemPlaced = true; if (!hintFlags.shelterPlaced) { showMessage("Shelter placed! Click to enter/exit. Press E nearby to pick up.", 4000); hintFlags.shelterPlaced = true; } } // Updated hint
                     else if (itemName === 'waterPurifier') { waterFilters.push(newObject); itemPlaced = true; if (!hintFlags.purifierPlaced) { showMessage("Purifier placed! Interact (E) for clean water.", 5000); hintFlags.purifierPlaced = true; } }

                     if (itemPlaced) {
                         removeItemFromInventory(itemName, 1);
                         showMessage(`Placed ${itemData.name}.`, 2500);
                     } else {
                         showMessage("Cannot place this item type (Error).", 2000);
                     }
                 }
                 return; // Explicit return after attempting placement
             }
         }

        function craftItem(event) {
             if (gameOver) return;
             const button = event.target.closest('.craft-button'); const itemId = button.dataset.item; const itemData = craftableItems[itemId]; if (!itemData) return;
             if (hasEnoughResources(itemData.requires)) { for (const resourceName in itemData.requires) { removeItemFromInventory(resourceName, itemData.requires[resourceName]); } addItemToInventory(itemId, 1); showMessage(`Crafted ${itemData.name}.`, 2500); updateCraftingUI(); } else { showMessage("Not enough resources.", 2000); }
         }

        // --- Inventory Management (Updated) ---
        function addItemToInventory(itemName, count) {
             if (count <= 0) return false; let addedSuccessfully = false;
             // First, try stacking with existing items
             for (let i = 0; i < inventory.length; i++) { if (inventory[i] && inventory[i].item === itemName) { inventory[i].count += count; addedSuccessfully = true; break; } }
              // If not stacked, try finding an empty slot ('none' or null/undefined)
             if (!addedSuccessfully) { for (let i = 0; i < inventory.length; i++) { if (!inventory[i] || inventory[i].item === 'none') { inventory[i] = { item: itemName, count: count }; addedSuccessfully = true; break; } } }
             // If no empty slots, add a new slot if not full
             if (!addedSuccessfully && inventory.length < MAX_INVENTORY_SIZE) { inventory.push({ item: itemName, count: count }); addedSuccessfully = true; }

             if (addedSuccessfully) {
                 // Ensure inventory doesn't exceed max size conceptually (shouldn't happen with checks above)
                 if (inventory.length > MAX_INVENTORY_SIZE) {
                     console.warn("Inventory exceeded max size - trimming.");
                     inventory = inventory.slice(0, MAX_INVENTORY_SIZE);
                     if(selectedSlot >= inventory.length) selectedSlot = Math.max(0, inventory.length - 1);
                 }
                 updateInventoryUI(); updateCraftingUI();
                 // Increment collection stats only for base resources
                 if (resources[itemName] && (itemName === 'wood' || itemName === 'stone')) { // Fish incremented in interactWorld
                      stats.totalItemsCollected += count;
                 }
                 return true;
              } else { showMessage("Inventory is full!", 2000); return false; }
         }

         function removeItemFromInventory(itemName, count) {
             if (count <= 0) return false;
             let remainingToRemove = count;
             let itemFound = false; // Track if we found the item at all

             // Iterate backwards to handle removing entire slots correctly
             for (let i = inventory.length - 1; i >= 0; i--) {
                 if (inventory[i] && inventory[i].item === itemName) {
                     itemFound = true;
                     let amountToRemoveFromSlot = Math.min(remainingToRemove, inventory[i].count);
                     inventory[i].count -= amountToRemoveFromSlot;
                     remainingToRemove -= amountToRemoveFromSlot;

                     if (inventory[i].count <= 0) {
                         if (selectedSlot === i) {
                             let newSelection = i - 1;
                             while (newSelection >= 0 && (!inventory[newSelection] || inventory[newSelection].item === 'none')) { newSelection--; }
                             if (newSelection < 0) { newSelection = i + 1; while (newSelection < inventory.length && (!inventory[newSelection] || inventory[newSelection].item === 'none')) { newSelection++; } }
                             if (newSelection < 0 || newSelection >= inventory.length || !inventory[newSelection] || inventory[newSelection].item === 'none') { const firstValid = inventory.findIndex(slot => slot && slot.item !== 'none'); selectInventorySlot(firstValid >= 0 ? firstValid : 0); } else { selectInventorySlot(newSelection); }
                         }
                         inventory[i] = { item: 'none', count: 0 };
                     }
                     if (remainingToRemove <= 0) { break; } // Exit loop if all items removed
                 }
             }
             while (inventory.length > 0 && inventory[inventory.length - 1].item === 'none') { inventory.pop(); }
             if (selectedSlot >= inventory.length) { selectedSlot = Math.max(0, inventory.length - 1); }

             if (remainingToRemove > 0 && itemFound) { console.warn(`Could not remove the full required ${count} of ${itemName}. Removed ${count - remainingToRemove}.`); }
             else if (remainingToRemove > 0 && !itemFound) { console.warn(`Could not remove ${count} of ${itemName}, item not found.`); updateInventoryUI(); return false; }

             updateInventoryUI();
             updateCraftingUI();
             return true;
         }

         function countItem(itemName) { let total = 0; for(const slot of inventory) { if(slot && slot.item === itemName) { total += slot.count; } } return total; }
         function hasEnoughResources(requirements) { return Object.entries(requirements).every(([res, reqCount]) => countItem(res) >= reqCount); }

        // --- Inventory Navigation ---
        function navigateInventoryLeft() {
            if (inventoryStartIndex > 0) {
                inventoryStartIndex--;
                if (selectedSlot >= inventoryStartIndex + VISIBLE_INVENTORY_SLOTS) { selectInventorySlot(inventoryStartIndex + VISIBLE_INVENTORY_SLOTS - 1); }
                updateInventoryUI();
            }
        }
        function navigateInventoryRight() {
            if (inventoryStartIndex + VISIBLE_INVENTORY_SLOTS < inventory.length) {
                inventoryStartIndex++;
                if (selectedSlot < inventoryStartIndex) { selectInventorySlot(inventoryStartIndex); }
                updateInventoryUI();
            }
        }

        // --- UI Update Functions (Modified for Inventory Sprites) ---
        function updateStatsUI() { statsPanel.health.textContent = Math.floor(stats.health); statsPanel.hunger.textContent = Math.floor(stats.hunger); statsPanel.thirst.textContent = Math.floor(stats.thirst); statsPanel.day.textContent = stats.day; }

        function updateInventoryUI() {
            const slots = inventorySlotsContainer.querySelectorAll('.inventory-slot');
            const currentInventorySize = inventory.length; // Use array length

            slots.forEach((slot, index) => {
                const actualIndex = inventoryStartIndex + index;
                slot.innerHTML = ''; // Clear previous content
                slot.classList.remove('selected', 'no-sprite');
                slot.style.backgroundImage = 'none';
                slot.style.backgroundPosition = '';
                slot.dataset.item = 'none'; // Default to none
                slot.dataset.actualIndex = actualIndex;

                if (actualIndex < currentInventorySize && inventory[actualIndex] && inventory[actualIndex].item !== 'none') {
                    const itemData = inventory[actualIndex];
                    const itemDef = craftableItems[itemData.item] || resources[itemData.item];
                    const displayName = itemDef?.name || itemData.item;

                    slot.dataset.item = itemData.item; // Set the item name

                    if (spritesheetLoaded && itemDef && itemDef.sprite) {
                         slot.style.backgroundImage = `url('${SPRITESHEET_SRC}')`;
                         const bgPosX = -itemDef.sprite.sx + 'px';
                         const bgPosY = -itemDef.sprite.sy + 'px';
                         slot.style.backgroundPosition = `${bgPosX} ${bgPosY}`;
                    } else {
                         slot.classList.add('no-sprite');
                         const nameSpan = document.createElement('span');
                         nameSpan.classList.add('inventory-item-name');
                         nameSpan.textContent = displayName;
                         slot.appendChild(nameSpan);
                    }
                    if (itemData.count > 0) {
                        const countSpan = document.createElement('span');
                        countSpan.classList.add('inventory-count');
                        countSpan.textContent = `x${itemData.count}`;
                        slot.appendChild(countSpan);
                    }
                    if (actualIndex === selectedSlot) { slot.classList.add('selected'); }
                } else {
                    slot.classList.add('no-sprite');
                    slot.dataset.item = 'none';
                }
            });

            invNavLeftButton.disabled = (inventoryStartIndex <= 0);
            invNavRightButton.disabled = (inventoryStartIndex + VISIBLE_INVENTORY_SLOTS >= inventory.length);
            updateTooltip();
        }


        // Selects based on the absolute index in the inventory array
        function selectInventorySlot(absoluteIndex) {
            const maxIndex = Math.max(0, inventory.length - 1);
             absoluteIndex = Math.max(0, Math.min(absoluteIndex, maxIndex));

             if (inventory[absoluteIndex] && inventory[absoluteIndex].item !== 'none') {
                 selectedSlot = absoluteIndex;
                 if (selectedSlot < inventoryStartIndex) { inventoryStartIndex = selectedSlot; }
                 else if (selectedSlot >= inventoryStartIndex + VISIBLE_INVENTORY_SLOTS) { inventoryStartIndex = selectedSlot - VISIBLE_INVENTORY_SLOTS + 1; }
                 updateInventoryUI();
             } else if (inventory.length === 0) {
                 selectedSlot = 0; inventoryStartIndex = 0; updateInventoryUI();
             } else {
                 // If target is empty, do nothing (keep current selection)
             }
        }


        function toggleCraftingMenu() { const panel = document.getElementById('crafting-panel'); const isVisible = panel.style.display === 'flex'; panel.style.display = isVisible ? 'none' : 'flex'; if (!isVisible) { updateCraftingUI(); } }
        function closeCraftingMenu() { document.getElementById('crafting-panel').style.display = 'none'; }
        function updateCraftingUI() { if (document.getElementById('crafting-panel').style.display !== 'flex') return; const buttons = document.querySelectorAll('#crafting-panel .craft-button'); buttons.forEach(button => { const itemId = button.dataset.item; const itemData = craftableItems[itemId]; if (itemData) { button.disabled = !hasEnoughResources(itemData.requires); } }); }
        function updateDayNightIndicator() { const ind = document.getElementById('day-night-indicator'); const tOD = time.current / time.dayLength; if (time.isNight) { ind.style.background = 'linear-gradient(to bottom, #1a1a4a, #00001a)'; ind.style.boxShadow = '0 0 10px rgba(50, 50, 100, 0.7)'; } else { ind.style.background = 'linear-gradient(to bottom, #87CEEB, #4682B4)'; ind.style.boxShadow = '0 0 10px rgba(135, 206, 235, 0.7)'; } }

        // --- Message & Hint Display ---
        function showMessage(message, duration = 3000) { messageBox.textContent = message; messageBox.style.display = 'block'; clearTimeout(messageTimeout); messageTimeout = setTimeout(() => { messageBox.style.display = 'none'; }, duration); }
        function showInteractionPrompt(message) { interactionPrompt.textContent = message; interactionPrompt.style.display = 'block'; clearTimeout(interactionTimeout); interactionTimeout = setTimeout(hideInteractionPrompt, 100); }
        function hideInteractionPrompt() { interactionPrompt.style.display = 'none'; }
        function updateTooltip() {
             const selected = inventory[selectedSlot]; let tooltipText = "";
             if (selected && selected.item !== 'none' && selected.count > 0) {
                 const itemDef = craftableItems[selected.item] || resources[selected.item];
                 if (itemDef) { tooltipText = `${itemDef.name || selected.item}: ${itemDef.description || 'A useful item.'}`; }
                 else { tooltipText = selected.item; }
             }
             if (tooltipText) { tooltipArea.textContent = tooltipText; tooltipArea.style.display = 'block'; }
             else { hideTooltip(); }
         }
        function hideTooltip() { tooltipArea.style.display = 'none'; }

        // --- Rendering ---
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.imageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            ctx.mozImageSmoothingEnabled = false;
            ctx.msImageSmoothingEnabled = false;

            drawBackgroundAndTerrain(ctx);

            // Combine all renderable objects including player and stumps
             const objectsToDraw = [
                 ...trees.filter(t => t.health > 0),
                 ...rocks.filter(r => r.health > 0),
                 ...bambooStands.filter(b => b.health > 0),
                 ...campfires,
                 ...shelters, // Include shelters in the main draw list
                 ...waterFilters,
                 ...signalFires,
                 ...trees.filter(t => t.health <= 0).map(t => ({ ...t, isStump: true, type: 'tree' })),
                 ...bambooStands.filter(b => b.health <= 0).map(b => ({ ...b, isStump: true, type: 'bamboo' })),
                 player // Add player to the list
             ];

            // Sort all entities based on their bottom Y coordinate
            objectsToDraw.sort((a, b) => (a.y + (a.height || TILE_SIZE)) - (b.y + (b.height || TILE_SIZE)));

            // Draw sorted entities
             objectsToDraw.forEach(obj => {
                 if (obj === player) {
                     drawPlayer(ctx, player);
                 } else if (obj.type === 'tree') { drawTree(ctx, obj); } // Stump
                 else if (trees.some(t => t.x === obj.x && t.y === obj.y && t.health > 0)) { drawTree(ctx, obj); } // Living Tree
                 else if (rocks.some(r => r.x === obj.x && r.y === obj.y && r.health > 0)) { drawRock(ctx, obj); } // Rock
                 else if (obj.type === 'bamboo') { drawBamboo(ctx, obj); } // Stump
                 else if (bambooStands.some(b => b.x === obj.x && b.y === obj.y && b.health > 0)) { drawBamboo(ctx, obj); } // Living Bamboo
                 else if (campfires.includes(obj)) { drawCampfire(ctx, obj); }
                 else if (shelters.includes(obj)) { drawShelter(ctx, obj); } // Draw shelter
                 else if (waterFilters.includes(obj)) { drawWaterPurifier(ctx, obj); }
                 else if (signalFires.includes(obj)) { drawSignalFire(ctx, obj); }
             });


            // Night Overlay
            if (time.isNight) {
                let darkness = 0;
                const timeOfDay = time.current / time.dayLength;
                const nightDurationFactor = (1.0 - time.nightStartFactor) + time.dayStartFactor;
                const fadeDurationFactor = nightDurationFactor / 2 * 0.8;
                if (timeOfDay >= time.nightStartFactor) { darkness = Math.min(0.6, (timeOfDay - time.nightStartFactor) / fadeDurationFactor * 0.6); }
                else if (timeOfDay < time.dayStartFactor) { darkness = Math.min(0.6, (time.dayStartFactor - timeOfDay) / fadeDurationFactor * 0.6); }
                else { darkness = 0; }
                darkness = Math.max(0, darkness);
                ctx.fillStyle = `rgba(0, 0, 30, ${darkness})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

         // --- Specific Drawing Functions ---

         // ============================================
         // ===== UPDATED drawBackgroundAndTerrain =====
         // ============================================
         function drawBackgroundAndTerrain(ctx) {
             const grassColor = '#8cc751';
             const sandColor = '#F4A460';
             const waterColor = '#3399FF'; // Water color
             const darkGrassColor = '#7bb540'; // For patches

             // 1. Draw Base Terrain Tiles
             for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
                 for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
                     let tileColor;
                     switch (world[y]?.[x]) {
                         case TERRAIN_GRASS: tileColor = grassColor; break;
                         case TERRAIN_SAND: tileColor = sandColor; break;
                         case TERRAIN_WATER: tileColor = waterColor; break;
                         default: tileColor = waterColor; // Default to water if undefined
                     }
                     ctx.fillStyle = tileColor;
                     ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                 }
             }

             // 2. Draw Grass Patches (only on grass tiles)
             ctx.fillStyle = darkGrassColor;
             for (const patch of grassPatches) {
                 ctx.fillRect(patch.x, patch.y, patch.w, patch.h);
             }
         }
         // ============================================
         // === END UPDATED drawBackgroundAndTerrain ===
         // ============================================


         function drawTree(ctx, obj) {
             // Stump drawing
             if (obj.isStump) {
                 ctx.fillStyle = '#8B4513'; // Darker brown for stump
                 ctx.fillRect(obj.x + obj.width * 0.3, obj.y + obj.height * 0.7, obj.width * 0.4, obj.height * 0.3);
             }
             // Living Tree drawing
             else {
                 const trunkColor = '#8B4513'; const trunkShadow = '#5C4033'; const leavesColor = '#228B22'; const leavesShadow = '#1A6A1A';
                 const trunkWidth = obj.width * 0.3; const trunkHeight = obj.height * 0.5; const trunkX = obj.x + (obj.width - trunkWidth) / 2; const trunkY = obj.y + obj.height - trunkHeight;
                 ctx.fillStyle = trunkShadow; ctx.fillRect(trunkX + trunkWidth * 0.7, trunkY, trunkWidth * 0.3, trunkHeight);
                 ctx.fillStyle = trunkColor; ctx.fillRect(trunkX, trunkY, trunkWidth, trunkHeight);
                 const leavesHeight = obj.height * 0.65; const leavesY = obj.y; const leavesCenterX = obj.x + obj.width / 2; const leavesRadius = obj.width / 2 * 1.1;
                 ctx.fillStyle = leavesShadow; ctx.beginPath(); ctx.ellipse(leavesCenterX, leavesY + leavesHeight * 0.6, leavesRadius * 0.8, leavesHeight * 0.4, 0, Math.PI * 0.1, Math.PI * 1.9); ctx.fill();
                 ctx.fillStyle = leavesColor; ctx.beginPath(); ctx.ellipse(leavesCenterX, leavesY + leavesHeight / 2, leavesRadius, leavesHeight / 2, 0, 0, Math.PI * 2); ctx.fill();
             }
         }
         function drawRock(ctx, obj) {
             const baseColor = '#808080'; const shadowColor = '#606060'; const highlightColor = '#A0A0A0';
             ctx.fillStyle = baseColor; ctx.beginPath(); ctx.moveTo(obj.x + obj.width * 0.1, obj.y + obj.height * 0.9); ctx.lineTo(obj.x + obj.width * 0.2, obj.y + obj.height * 0.2); ctx.lineTo(obj.x + obj.width * 0.8, obj.y + obj.height * 0.1); ctx.lineTo(obj.x + obj.width * 0.9, obj.y + obj.height * 0.8); ctx.closePath(); ctx.fill();
             ctx.fillStyle = shadowColor; ctx.beginPath(); ctx.moveTo(obj.x + obj.width * 0.1, obj.y + obj.height * 0.9); ctx.lineTo(obj.x + obj.width * 0.5, obj.y + obj.height * 0.5); ctx.lineTo(obj.x + obj.width * 0.9, obj.y + obj.height * 0.8); ctx.closePath(); ctx.fill();
             ctx.fillStyle = highlightColor; ctx.beginPath(); ctx.moveTo(obj.x + obj.width * 0.2, obj.y + obj.height * 0.2); ctx.lineTo(obj.x + obj.width * 0.8, obj.y + obj.height * 0.1); ctx.lineTo(obj.x + obj.width * 0.5, obj.y + obj.height * 0.5); ctx.closePath(); ctx.fill();
         }
         function drawBamboo(ctx, obj) {
              const stalkColor = '#55A63A'; const shadowColor = '#387D2A'; const stumpColor = '#C1A875';
              if (obj.isStump) {
                  ctx.fillStyle = stumpColor; ctx.beginPath(); ctx.moveTo(obj.x, obj.y + obj.height); ctx.lineTo(obj.x + obj.width * 0.2, obj.y + obj.height * 0.8); ctx.lineTo(obj.x + obj.width * 0.5, obj.y + obj.height * 0.9); ctx.lineTo(obj.x + obj.width * 0.8, obj.y + obj.height * 0.85); ctx.lineTo(obj.x + obj.width, obj.y + obj.height); ctx.closePath(); ctx.fill();
              } else {
                  const numStalks = 3; const stalkWidth = obj.width / (numStalks + 1); const spacing = stalkWidth * 0.3;
                  for (let i = 0; i < numStalks; i++) {
                      const stalkX = obj.x + spacing + i * (stalkWidth + spacing); const stalkHeight = obj.height * (0.8 + Math.random() * 0.2); const stalkY = obj.y + obj.height - stalkHeight;
                      ctx.fillStyle = stalkColor; ctx.fillRect(stalkX, stalkY, stalkWidth, stalkHeight);
                      ctx.fillStyle = shadowColor; const nodeHeight = stalkHeight / 8; for (let j = 0; j < 5; j++) { ctx.fillRect(stalkX, stalkY + j * stalkHeight / 5, stalkWidth, nodeHeight); } ctx.fillRect(stalkX + stalkWidth * 0.7, stalkY, stalkWidth * 0.3, stalkHeight);
                  }
              }
         }
         function drawPlayer(ctx, p) {
             ctx.save(); ctx.globalAlpha = p.alpha;
             const skinColor = '#F0C8A0'; const hairColor = '#5B3A29'; const shirtColor = '#4682B4'; const pantsColor = '#3B5323'; const eyeColor = '#000000'; const shoeColor = '#8B4513';
             const headSize = p.width * 0.6; const headX = p.x + (p.width - headSize) / 2; const headY = p.y; const bodyWidth = p.width * 0.8; const bodyHeight = p.height * 0.5; const bodyX = p.x + (p.width - bodyWidth) / 2; const bodyY = headY + headSize * 0.8; const legHeight = p.height * 0.3; const legWidth = bodyWidth / 2 * 0.8; const legY = bodyY + bodyHeight * 0.9;
             ctx.fillStyle = pantsColor; ctx.fillRect(bodyX, legY, legWidth, legHeight); ctx.fillRect(bodyX + bodyWidth - legWidth, legY, legWidth, legHeight);
             ctx.fillStyle = shoeColor; const shoeHeight = legHeight * 0.3; ctx.fillRect(bodyX, legY + legHeight - shoeHeight, legWidth, shoeHeight); ctx.fillRect(bodyX + bodyWidth - legWidth, legY + legHeight - shoeHeight, legWidth, shoeHeight);
             ctx.fillStyle = shirtColor; ctx.fillRect(bodyX, bodyY, bodyWidth, bodyHeight);
             ctx.fillStyle = skinColor; ctx.fillRect(headX, headY, headSize, headSize);
             ctx.fillStyle = hairColor; ctx.fillRect(headX, headY, headSize, headSize * 0.3);
             if (p.direction === 'left') { ctx.fillRect(headX, headY + headSize * 0.2, headSize * 0.2, headSize * 0.5); } else if (p.direction === 'right') { ctx.fillRect(headX + headSize * 0.8, headY + headSize * 0.2, headSize * 0.2, headSize * 0.5); } else if (p.direction === 'down') { ctx.fillRect(headX + headSize * 0.1, headY + headSize * 0.3, headSize * 0.8, headSize * 0.2); }
             ctx.fillStyle = eyeColor; const eyeY = headY + headSize * 0.4; const eyeSize = 2;
             if (p.direction === 'down') { ctx.fillRect(headX + headSize * 0.25, eyeY, eyeSize, eyeSize); ctx.fillRect(headX + headSize * 0.65, eyeY, eyeSize, eyeSize); } else if (p.direction === 'left') { ctx.fillRect(headX + headSize * 0.25, eyeY, eyeSize, eyeSize); } else if (p.direction === 'right') { ctx.fillRect(headX + headSize * 0.65, eyeY, eyeSize, eyeSize); }
             const armWidth = bodyWidth * 0.15; const armHeight = bodyHeight * 0.8; const armY = bodyY + bodyHeight * 0.1; ctx.fillStyle = skinColor;
             if (p.direction === 'down' || p.direction === 'up') { ctx.fillRect(bodyX - armWidth, armY, armWidth, armHeight); ctx.fillRect(bodyX + bodyWidth, armY, armWidth, armHeight); } else if (p.direction === 'left') { ctx.fillRect(bodyX + bodyWidth * 0.1, armY, armWidth, armHeight); } else if (p.direction === 'right') { ctx.fillRect(bodyX + bodyWidth * 0.75 , armY, armWidth, armHeight); }
             ctx.restore();
         }
         function drawCampfire(ctx, obj) {
             const stoneColor = '#696969'; const woodColor = '#A0522D'; const fireColor1 = '#FFA500'; const fireColor2 = '#FF8C00'; const fireColor3 = '#FF6347';
             const baseRadius = obj.width * 0.4; const centerX = obj.x + obj.width / 2; const centerY = obj.y + obj.height * 0.7;
             ctx.fillStyle = stoneColor; ctx.beginPath(); ctx.arc(centerX, centerY, baseRadius, 0, Math.PI * 2); ctx.fill();
             ctx.fillStyle = woodColor; ctx.fillRect(centerX - baseRadius * 0.6, centerY - baseRadius * 0.2, baseRadius * 1.2, baseRadius * 0.4); ctx.fillRect(centerX - baseRadius * 0.2, centerY - baseRadius * 0.6, baseRadius * 0.4, baseRadius * 1.2);
             const fireHeightBase = obj.height * 0.7; const fireWidthBase = obj.width * 0.6; const fireBottomY = obj.y + obj.height * 0.3;
             for (let i = 0; i < 3; i++) { const flickerX = (Math.random() - 0.5) * fireWidthBase * 0.3; const flickerY = Math.random() * fireHeightBase * 0.2; const flickerW = fireWidthBase * (0.6 + Math.random() * 0.4); const flickerH = fireHeightBase * (0.7 + Math.random() * 0.3); let fireColor = fireColor1; const randColor = Math.random(); if (randColor > 0.66) fireColor = fireColor3; else if (randColor > 0.33) fireColor = fireColor2; ctx.fillStyle = fireColor; ctx.beginPath(); ctx.ellipse(centerX + flickerX, fireBottomY + flickerH / 2 - flickerY, flickerW / 2, flickerH / 2, 0, 0, Math.PI * 2); ctx.fill(); }
         }
         function drawShelter(ctx, obj) {
             const wallColor = '#A0522D'; const roofColor = '#8B7355'; const frameColor = '#5C4033'; const floorColor = '#D2B48C';
             ctx.fillStyle = floorColor; ctx.fillRect(obj.x, obj.y + obj.height * 0.85, obj.width, obj.height * 0.15);
             ctx.fillStyle = wallColor; ctx.fillRect(obj.x + obj.width * 0.1, obj.y + obj.height * 0.2, obj.width * 0.8, obj.height * 0.65);
             ctx.fillStyle = roofColor; ctx.beginPath(); ctx.moveTo(obj.x, obj.y + obj.height * 0.3); ctx.lineTo(obj.x + obj.width / 2, obj.y); ctx.lineTo(obj.x + obj.width, obj.y + obj.height * 0.3); ctx.lineTo(obj.x + obj.width * 0.9, obj.y + obj.height * 0.85); ctx.lineTo(obj.x + obj.width * 0.1, obj.y + obj.height * 0.85); ctx.closePath(); ctx.fill();
             ctx.strokeStyle = frameColor; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(obj.x, obj.y + obj.height * 0.3); ctx.lineTo(obj.x + obj.width / 2, obj.y); ctx.lineTo(obj.x + obj.width, obj.y + obj.height * 0.3); ctx.stroke(); ctx.strokeRect(obj.x + obj.width * 0.3, obj.y + obj.height * 0.4, obj.width * 0.4, obj.height * 0.45);
         }

         function drawWaterPurifier(ctx, obj) {
            const x = obj.x; const y = obj.y; const w = obj.width; const h = obj.height;
            const stoneColor = '#888c8d'; const stoneShadow = '#65696a'; const woodColor = '#8B4513'; const woodShadow = '#5C4033'; const waterColor = '#60a5fa'; const charcoalColor = '#333'; const sandColor = '#D2B48C';
            ctx.fillStyle = stoneShadow; ctx.fillRect(x + w * 0.1, y + h * 0.75, w * 0.3, h * 0.25); ctx.fillRect(x + w * 0.6, y + h * 0.8, w * 0.35, h * 0.2);
            ctx.fillStyle = stoneColor; ctx.fillRect(x + w * 0.15, y + h * 0.7, w * 0.28, h * 0.25); ctx.fillRect(x + w * 0.55, y + h * 0.75, w * 0.33, h * 0.2); ctx.fillRect(x + w * 0.35, y + h * 0.65, w * 0.3, h * 0.28);
            const containerY = y + h * 0.1; const containerH = h * 0.55; ctx.fillStyle = woodShadow; ctx.fillRect(x, containerY + containerH * 0.1, w, containerH * 0.9);
            ctx.fillStyle = woodColor; ctx.fillRect(x + w * 0.05, containerY, w * 0.9, containerH); ctx.fillStyle = woodShadow; ctx.fillRect(x + w * 0.15, containerY + h * 0.05, w * 0.7, h * 0.1);
            const layerYStart = containerY + h * 0.15; const layerHeight = h * 0.12; ctx.fillStyle = charcoalColor; ctx.fillRect(x + w * 0.15, layerYStart, w * 0.7, layerHeight); ctx.fillStyle = sandColor; ctx.fillRect(x + w * 0.15, layerYStart + layerHeight, w * 0.7, layerHeight * 0.8);
            ctx.fillStyle = waterColor; ctx.globalAlpha = 0.7; ctx.fillRect(x + w * 0.15, containerY + h * 0.05, w * 0.7, h * 0.1); ctx.globalAlpha = 1.0;
            ctx.fillStyle = woodShadow; ctx.beginPath(); ctx.moveTo(x + w * 0.4, y + h * 0.8); ctx.lineTo(x + w * 0.45, y + h * 0.95); ctx.lineTo(x + w * 0.55, y + h * 0.95); ctx.lineTo(x + w * 0.6, y + h * 0.8); ctx.closePath(); ctx.fill();
         }

         function drawSignalFire(ctx, obj) {
             const stoneColor = '#696969'; const woodColor = '#A0522D'; const fireColor1 = '#FFA500'; const fireColor2 = '#FF8C00'; const fireColor3 = '#FF6347'; const smokeColor = 'rgba(100, 100, 100, 0.5)';
             ctx.fillStyle = stoneColor; const baseHeight = obj.height * 0.4; ctx.fillRect(obj.x, obj.y + obj.height - baseHeight, obj.width, baseHeight); ctx.fillStyle = '#505050'; ctx.fillRect(obj.x + obj.width * 0.1, obj.y + obj.height - baseHeight * 0.8, obj.width*0.8, baseHeight * 0.2); ctx.fillRect(obj.x + obj.width * 0.3, obj.y + obj.height - baseHeight * 0.4, obj.width*0.4, baseHeight * 0.2);
             ctx.fillStyle = woodColor; const woodPileY = obj.y + obj.height * 0.3; const woodPileH = obj.height * 0.3; ctx.fillRect(obj.x + obj.width * 0.1, woodPileY, obj.width * 0.8, woodPileH); ctx.fillRect(obj.x + obj.width * 0.3, woodPileY - woodPileH*0.4, obj.width * 0.4, woodPileH*1.2);
             if (obj.isBurning) {
                 const fireHeightBase = obj.height * 0.6; const fireWidthBase = obj.width * 0.7; const fireBottomY = obj.y + obj.height * 0.1; const centerX = obj.x + obj.width / 2;
                 for (let i = 0; i < 4; i++) { const flickerX = (Math.random() - 0.5) * fireWidthBase * 0.4; const flickerY = Math.random() * fireHeightBase * 0.3; const flickerW = fireWidthBase * (0.5 + Math.random() * 0.5); const flickerH = fireHeightBase * (0.8 + Math.random() * 0.4); let fireColor = fireColor1; const randColor = Math.random(); if (randColor > 0.66) fireColor = fireColor3; else if (randColor > 0.33) fireColor = fireColor2; ctx.fillStyle = fireColor; ctx.beginPath(); ctx.ellipse(centerX + flickerX, fireBottomY + flickerH / 2 - flickerY, flickerW / 2, flickerH / 2, Math.PI * (1.4 + Math.random()*0.2), 0, Math.PI * 2); ctx.fill(); }
                 ctx.fillStyle = smokeColor; for (let i = 0; i < 5; i++) { const smokeX = centerX + (Math.random() - 0.5) * obj.width * 0.5; const smokeY = obj.y - i * 10 - Math.random() * 15; const smokeRadius = obj.width * 0.1 + Math.random() * obj.width * 0.15; ctx.beginPath(); ctx.arc(smokeX, smokeY, smokeRadius, 0, Math.PI * 2); ctx.fill(); }
             } else { ctx.fillStyle = '#444'; ctx.fillRect(obj.x + obj.width * 0.2, woodPileY + woodPileH * 0.5, obj.width * 0.6, woodPileH * 0.3); }
         }

        // --- Helper Functions ---
        function checkCollision(x1, y1, w1, h1, x2, y2, w2, h2) { return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2; }
        function dist(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }
        function isPlayerNearObject(objectList, maxDistance, targetX = player.x + player.width / 2, targetY = player.y + player.height / 2) { for (const obj of objectList) { if (dist(targetX, targetY, obj.x + obj.width / 2, obj.y + obj.height / 2) < maxDistance) return true; } return false; }

        // Modified Interaction Point: Offset based on direction
        function getInteractionPoint() {
             let ix = player.x + player.width / 2;
             let iy = player.y + player.height / 2;
             const reach = TILE_SIZE * 0.6; // How far the interaction point projects

             switch (player.direction) {
                 case 'up': iy -= reach; break;
                 case 'down': iy += reach + (player.height / 2); break; // Project further down
                 case 'left': ix -= reach; break;
                 case 'right': ix += reach; break;
             }
             // Clamp interaction point within world bounds (optional, but good practice)
             ix = Math.max(0, Math.min(WORLD_WIDTH - 1, ix));
             iy = Math.max(0, Math.min(WORLD_HEIGHT - 1, iy));

             return { x: ix, y: iy };
         }


        // --- Start Initialization ---
        initGame(); // Call last

    </script>
</body>
</html>
